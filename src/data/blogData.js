const blogData ={
  "status": "ok",
  "feed": {
      "url": "https://medium.com/feed/@tkssharma",
      "title": "Stories by Tarun Sharma on Medium",
      "link": "https://medium.com/@tkssharma?source=rss-9bea52c4baff------2",
      "author": "",
      "description": "Stories by Tarun Sharma on Medium",
      "image": "https://cdn-images-1.medium.com/fit/c/150/150/0*5l2lWIXJn5av6Lh5.jpg"
  },
  "items": [
      {
          "title": "Learning Typescript in Depth 3.x.x",
          "pubDate": "2018-10-28 01:41:16",
          "link": "https://medium.com/@tkssharma/learning-typescript-in-depth-3-x-x-4aa427e98fc6?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/4aa427e98fc6",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/1024/1*0r4CMSULZkUCMfv-hiFU7A.png",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0r4CMSULZkUCMfv-hiFU7A.png\"></figure><p>Since 2012, TypeScript has been a popular choice for programmers coming to JavaScript from more structured languages (like C++ or Java). But it’s also been largely dismissed by those native to the JavaScript world.</p>\n<p>You may have heard that the Angular team recently <a href=\"https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8\">switched to TypeScript for Angular 2</a>. So have the teams behind <a href=\"https://github.com/ReactiveX/rxjs\">RxJS</a>, <a href=\"https://blog.ionic.io/announcing-ionic-2-0-0-final/\">Ionic</a>, <a href=\"https://cycle.js.org/\">Cycle.js</a>, <a href=\"https://github.com/palantir/blueprint\">Blueprint</a>, <a href=\"https://dojotoolkit.org/community/roadmap/vision.html\">Dojo</a>, <a href=\"https://github.com/NativeScript/NativeScript\">NativeScript</a>, <a href=\"https://github.com/palantir/plottable\">Plottable</a>, and others.</p>\n<p>If you’ve been in JavaScript/Node.js land for a while, it’s easy to assume that the shot-callers for these projects have lost their minds. Or maybe that they were paid off by Microsoft. 👀</p>\n<p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6iZRxm29jTTDu1z91fo0iA.jpeg\"></figure><p>And if you haven’t been watching closely, you may have missed TypeScript’s amazing progress over the past year (and even the past few months).</p>\n<p><strong>If you’re still thinking “TypeScript is kinda like CoffeeScript, right?” — this article is for you.</strong></p>\n<p>Typescript is something which is adding types in your application to make it full proof application.</p>\n<h3>TypeScript is JavaScript with better linting</h3>\n<p>Probably one of the most common concerns with the idea of using TypeScript is that it isn’t <em>pure</em> JavaScript. Because TypeScript is its own language, it’s assumed your code will be transpiled into a messy glob which you’ll someday be forced to debug.</p>\n<p>Besides TypeScript being extremely well-tested and widely in use, it’s worth noting that depending on your configuration, very little “transpiling” is actually happening (if any). TypeScript is just Javascript with optional typings.</p>\n<a href=\"https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href\">https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href</a><a href=\"https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href\">https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href</a><p>let’s Learn Typescript building blocks</p>\n<h4>Typescript Compiler</h4>\n<p>There are two main ways to get the TypeScript tools:</p>\n<ul>\n<li>Via npm (the Node.js package manager)</li>\n<li>By installing TypeScript’s Visual Studio plugins</li>\n</ul>\n<p>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn’t install TypeScript with Visual Studio, you can still <a href=\"https://www.typescriptlang.org/#download-links\">download it</a>.</p>\n<p>For NPM users:</p>\n<pre>&gt; npm install -g typescript</pre>\n<h3>Building your first TypeScript file</h3>\n<p>In your editor, type the following JavaScript code in greeter.ts:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Compiling your code</h3>\n<p>We used a .ts extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</p>\n<p>At the command line, run the TypeScript compiler:</p>\n<pre>tsc greeter.ts</pre>\n<p>The result will be a file greeter.js which contains the same JavaScript that you fed in. We’re up and running using TypeScript in our JavaScript app!</p>\n<p>Now we can start taking advantage of some of the new tools TypeScript offers. Add a : string type annotation to the ‘person’ function argument as shown here:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Type annotations</h3>\n<p>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = [0, 1, 2];</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<p>Re-compiling, you’ll now see an error:</p>\n<pre>error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.</pre>\n<p>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</p>\n<p>Notice that although there were errors, the greeter.js file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</p>\n<a href=\"https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href\">https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href</a><p>Union Type, optional type, array literal with types</p>\n<a href=\"https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href\">https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href</a><p>The non-primitive group includes void, string literal, tuple, any, unknown, and never</p>\n<h3>Void &amp; NeverTypes</h3>\n<p>In TypeScript 2.0, a new primitive type called never was introduced. It represents the type of values that never occur. The never type is used in the following two places:</p>\n<ul>\n<li>As the return type of <strong>functions that never return</strong>.</li>\n<li>As the type of variables under <strong>type guards that are never true</strong>.</li>\n</ul>\n<h3>Union Types</h3>\n<p>Union types are closely related to intersection types, but they are used very differently. Occasionally, you’ll run into a library that expects a parameter to be either a number or a string. For instance, take the following function:</p>\n<pre>/**<br> * Takes a string and adds \"padding\" to the left.<br> * If 'padding' is a string, then 'padding' is appended to the left side.<br> * If 'padding' is a number, then that number of spaces is added to the left side.<br> */<br><strong>function</strong> <strong>padLeft</strong>(value: string, padding: any) {<br><strong>if</strong> (<strong>typeof</strong> padding === \"number\") {<br><strong>return</strong> Array(padding + 1).join(\" \") + value;<br>    }<br><strong>if</strong> (<strong>typeof</strong> padding === \"string\") {<br><strong>return</strong> padding + value;<br>    }<br><strong>throw</strong> <strong>new</strong> Error(`Expected string or number, got '${padding}'.`);<br>}</pre>\n<pre>padLeft(\"Hello world\", 4); // returns \"    Hello world\"</pre>\n<p>The problem with padLeft is that its padding parameter is typed as any. That means that we can call it with an argument that’s neither a number nor a string, but TypeScript will be okay with it.</p>\n<a href=\"https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href\">https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href</a><h3>Enums</h3>\n<p>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</p>\n<h3>Numeric enums</h3>\n<p>We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages. An enum can be defined using the enum keyword.</p>\n<pre><strong>enum</strong> Direction {<br>    Up = 1,<br>    Down,<br>    Left,<br>    Right,<br>}</pre>\n<p>Above, we have a numeric enum where Up is initialized with 1. All of the following members are auto-incremented from that point on. In other words, Direction.Up has the value 1, Down has 2, Left has 3, and Right has 4.</p>\n<a href=\"https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href\">https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href</a><h3>Interfaces</h3>\n<p>One of TypeScript’s core principles is that type-checking focuses on the <em>shape</em> that values have. This is sometimes called “duck typing” or “structural subtyping”. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</p>\n<h4>Our First Interface</h4>\n<p>The easiest way to see how interfaces work is to start with a simple example:</p>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: { label: string }) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<p>The type-checker checks the call to printLabel. The printLabel function has a single parameter that requires that the object passed in has a property called label of type string. Notice that our object actually has more properties than this, but the compiler only checks that <em>at least</em> the ones required are present and match the types required. There are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit.</p>\n<p>We can write the same example again, this time using an interface to describe the requirement of having the labelproperty that is a string:</p>\n<pre><strong>interface</strong> LabelledValue {<br>    label: string;<br>}</pre>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: LabelledValue) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<a href=\"https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href\">https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href</a><h3>Generics&lt;T&gt;</h3>\n<p>To start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echo command.</p>\n<p>Without generics, we would either have to give the identity function a specific type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: number): <strong>number</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>Or, we could describe the identity function using the any type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: any): <strong>any</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>While using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</p>\n<p>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a <em>type variable</em>, a special kind of variable that works on types rather than values.</p>\n<pre><strong>function</strong> <strong>identity</strong>&lt;<strong>T</strong>&gt;(arg: T): <strong>T</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>We’ve now added a type variable T to the identity function. This T allows us to capture the type the user provides (e.g. number), so that we can use that information later. Here, we use T again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</p>\n<p>We say that this version of the identity function is generic, as it works over a range of types. Unlike using any, it’s also just as precise (ie, it doesn’t lose any information) as the first identity function that used numbers for the argument and return type.</p>\n<p>Once we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</p>\n<a href=\"https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href\">https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href</a><h4>More Available on Scrimba</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*OYcK0HPBQbr5W3KbmasOhw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*aTGEcFaBl4XUfKqSq7gp8g.png\"></figure><p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4aa427e98fc6\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*0r4CMSULZkUCMfv-hiFU7A.png\"></figure><p>Since 2012, TypeScript has been a popular choice for programmers coming to JavaScript from more structured languages (like C++ or Java). But it’s also been largely dismissed by those native to the JavaScript world.</p>\n<p>You may have heard that the Angular team recently <a href=\"https://vsavkin.com/writing-angular-2-in-typescript-1fa77c78d8e8\">switched to TypeScript for Angular 2</a>. So have the teams behind <a href=\"https://github.com/ReactiveX/rxjs\">RxJS</a>, <a href=\"https://blog.ionic.io/announcing-ionic-2-0-0-final/\">Ionic</a>, <a href=\"https://cycle.js.org/\">Cycle.js</a>, <a href=\"https://github.com/palantir/blueprint\">Blueprint</a>, <a href=\"https://dojotoolkit.org/community/roadmap/vision.html\">Dojo</a>, <a href=\"https://github.com/NativeScript/NativeScript\">NativeScript</a>, <a href=\"https://github.com/palantir/plottable\">Plottable</a>, and others.</p>\n<p>If you’ve been in JavaScript/Node.js land for a while, it’s easy to assume that the shot-callers for these projects have lost their minds. Or maybe that they were paid off by Microsoft. 👀</p>\n<p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*6iZRxm29jTTDu1z91fo0iA.jpeg\"></figure><p>And if you haven’t been watching closely, you may have missed TypeScript’s amazing progress over the past year (and even the past few months).</p>\n<p><strong>If you’re still thinking “TypeScript is kinda like CoffeeScript, right?” — this article is for you.</strong></p>\n<p>Typescript is something which is adding types in your application to make it full proof application.</p>\n<h3>TypeScript is JavaScript with better linting</h3>\n<p>Probably one of the most common concerns with the idea of using TypeScript is that it isn’t <em>pure</em> JavaScript. Because TypeScript is its own language, it’s assumed your code will be transpiled into a messy glob which you’ll someday be forced to debug.</p>\n<p>Besides TypeScript being extremely well-tested and widely in use, it’s worth noting that depending on your configuration, very little “transpiling” is actually happening (if any). TypeScript is just Javascript with optional typings.</p>\n<a href=\"https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href\">https://medium.com/media/494954808fd634c8fc862fdec4eb86cd/href</a><a href=\"https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href\">https://medium.com/media/a9a3d6608052965c2883dd73b594c7c1/href</a><p>let’s Learn Typescript building blocks</p>\n<h4>Typescript Compiler</h4>\n<p>There are two main ways to get the TypeScript tools:</p>\n<ul>\n<li>Via npm (the Node.js package manager)</li>\n<li>By installing TypeScript’s Visual Studio plugins</li>\n</ul>\n<p>Visual Studio 2017 and Visual Studio 2015 Update 3 include TypeScript by default. If you didn’t install TypeScript with Visual Studio, you can still <a href=\"https://www.typescriptlang.org/#download-links\">download it</a>.</p>\n<p>For NPM users:</p>\n<pre>&gt; npm install -g typescript</pre>\n<h3>Building your first TypeScript file</h3>\n<p>In your editor, type the following JavaScript code in greeter.ts:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Compiling your code</h3>\n<p>We used a .ts extension, but this code is just JavaScript. You could have copy/pasted this straight out of an existing JavaScript app.</p>\n<p>At the command line, run the TypeScript compiler:</p>\n<pre>tsc greeter.ts</pre>\n<p>The result will be a file greeter.js which contains the same JavaScript that you fed in. We’re up and running using TypeScript in our JavaScript app!</p>\n<p>Now we can start taking advantage of some of the new tools TypeScript offers. Add a : string type annotation to the ‘person’ function argument as shown here:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = \"Jane User\";</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<h3>Type annotations</h3>\n<p>Type annotations in TypeScript are lightweight ways to record the intended contract of the function or variable. In this case, we intend the greeter function to be called with a single string parameter. We can try changing the call greeter to pass an array instead:</p>\n<pre><strong>function</strong> <strong>greeter</strong>(person: string) {<br><strong>return</strong> \"Hello, \" + person;<br>}</pre>\n<pre><strong>let</strong> user = [0, 1, 2];</pre>\n<pre>document.body.innerHTML = greeter(user);</pre>\n<p>Re-compiling, you’ll now see an error:</p>\n<pre>error TS2345: Argument of type 'number[]' is not assignable to parameter of type 'string'.</pre>\n<p>Similarly, try removing all the arguments to the greeter call. TypeScript will let you know that you have called this function with an unexpected number of parameters. In both cases, TypeScript can offer static analysis based on both the structure of your code, and the type annotations you provide.</p>\n<p>Notice that although there were errors, the greeter.js file is still created. You can use TypeScript even if there are errors in your code. But in this case, TypeScript is warning that your code will likely not run as expected.</p>\n<a href=\"https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href\">https://medium.com/media/83e86eaaef5df7c78fd87ec0495d00f8/href</a><p>Union Type, optional type, array literal with types</p>\n<a href=\"https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href\">https://medium.com/media/f0d49e3f2526a4d9026c79a586013f03/href</a><p>The non-primitive group includes void, string literal, tuple, any, unknown, and never</p>\n<h3>Void &amp; NeverTypes</h3>\n<p>In TypeScript 2.0, a new primitive type called never was introduced. It represents the type of values that never occur. The never type is used in the following two places:</p>\n<ul>\n<li>As the return type of <strong>functions that never return</strong>.</li>\n<li>As the type of variables under <strong>type guards that are never true</strong>.</li>\n</ul>\n<h3>Union Types</h3>\n<p>Union types are closely related to intersection types, but they are used very differently. Occasionally, you’ll run into a library that expects a parameter to be either a number or a string. For instance, take the following function:</p>\n<pre>/**<br> * Takes a string and adds \"padding\" to the left.<br> * If 'padding' is a string, then 'padding' is appended to the left side.<br> * If 'padding' is a number, then that number of spaces is added to the left side.<br> */<br><strong>function</strong> <strong>padLeft</strong>(value: string, padding: any) {<br><strong>if</strong> (<strong>typeof</strong> padding === \"number\") {<br><strong>return</strong> Array(padding + 1).join(\" \") + value;<br>    }<br><strong>if</strong> (<strong>typeof</strong> padding === \"string\") {<br><strong>return</strong> padding + value;<br>    }<br><strong>throw</strong> <strong>new</strong> Error(`Expected string or number, got '${padding}'.`);<br>}</pre>\n<pre>padLeft(\"Hello world\", 4); // returns \"    Hello world\"</pre>\n<p>The problem with padLeft is that its padding parameter is typed as any. That means that we can call it with an argument that’s neither a number nor a string, but TypeScript will be okay with it.</p>\n<a href=\"https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href\">https://medium.com/media/be2d87f434575ed08e3b3479c8e47f59/href</a><h3>Enums</h3>\n<p>Enums allow us to define a set of named constants. Using enums can make it easier to document intent, or create a set of distinct cases. TypeScript provides both numeric and string-based enums.</p>\n<h3>Numeric enums</h3>\n<p>We’ll first start off with numeric enums, which are probably more familiar if you’re coming from other languages. An enum can be defined using the enum keyword.</p>\n<pre><strong>enum</strong> Direction {<br>    Up = 1,<br>    Down,<br>    Left,<br>    Right,<br>}</pre>\n<p>Above, we have a numeric enum where Up is initialized with 1. All of the following members are auto-incremented from that point on. In other words, Direction.Up has the value 1, Down has 2, Left has 3, and Right has 4.</p>\n<a href=\"https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href\">https://medium.com/media/950c0fe6e9f13c9ab6910051f4eb1699/href</a><h3>Interfaces</h3>\n<p>One of TypeScript’s core principles is that type-checking focuses on the <em>shape</em> that values have. This is sometimes called “duck typing” or “structural subtyping”. In TypeScript, interfaces fill the role of naming these types, and are a powerful way of defining contracts within your code as well as contracts with code outside of your project.</p>\n<h4>Our First Interface</h4>\n<p>The easiest way to see how interfaces work is to start with a simple example:</p>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: { label: string }) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<p>The type-checker checks the call to printLabel. The printLabel function has a single parameter that requires that the object passed in has a property called label of type string. Notice that our object actually has more properties than this, but the compiler only checks that <em>at least</em> the ones required are present and match the types required. There are some cases where TypeScript isn’t as lenient, which we’ll cover in a bit.</p>\n<p>We can write the same example again, this time using an interface to describe the requirement of having the labelproperty that is a string:</p>\n<pre><strong>interface</strong> LabelledValue {<br>    label: string;<br>}</pre>\n<pre><strong>function</strong> <strong>printLabel</strong>(labelledObj: LabelledValue) {<br>    console.log(labelledObj.label);<br>}</pre>\n<pre><strong>let</strong> myObj = {size: 10, label: \"Size 10 Object\"};<br>printLabel(myObj);</pre>\n<a href=\"https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href\">https://medium.com/media/7829141b9ac2532bed0e017a39b35713/href</a><h3>Generics&lt;T&gt;</h3>\n<p>To start off, let’s do the “hello world” of generics: the identity function. The identity function is a function that will return back whatever is passed in. You can think of this in a similar way to the echo command.</p>\n<p>Without generics, we would either have to give the identity function a specific type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: number): <strong>number</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>Or, we could describe the identity function using the any type:</p>\n<pre><strong>function</strong> <strong>identity</strong>(arg: any): <strong>any</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>While using any is certainly generic in that it will cause the function to accept any and all types for the type of arg, we actually are losing the information about what that type was when the function returns. If we passed in a number, the only information we have is that any type could be returned.</p>\n<p>Instead, we need a way of capturing the type of the argument in such a way that we can also use it to denote what is being returned. Here, we will use a <em>type variable</em>, a special kind of variable that works on types rather than values.</p>\n<pre><strong>function</strong> <strong>identity</strong>&lt;<strong>T</strong>&gt;(arg: T): <strong>T</strong> {<br><strong>return</strong> arg;<br>}</pre>\n<p>We’ve now added a type variable T to the identity function. This T allows us to capture the type the user provides (e.g. number), so that we can use that information later. Here, we use T again as the return type. On inspection, we can now see the same type is used for the argument and the return type. This allows us to traffic that type information in one side of the function and out the other.</p>\n<p>We say that this version of the identity function is generic, as it works over a range of types. Unlike using any, it’s also just as precise (ie, it doesn’t lose any information) as the first identity function that used numbers for the argument and return type.</p>\n<p>Once we’ve written the generic identity function, we can call it in one of two ways. The first way is to pass all of the arguments, including the type argument, to the function:</p>\n<a href=\"https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href\">https://medium.com/media/fc16015dc32fa2cc15ecb49b88d05d23/href</a><h4>More Available on Scrimba</h4>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/600/1*OYcK0HPBQbr5W3KbmasOhw.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*aTGEcFaBl4XUfKqSq7gp8g.png\"></figure><p><a href=\"https://scrimba.com/playlist/pKpMECK\">Scrimba - Playlist Understanding Typescript In Depth</a></p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=4aa427e98fc6\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "nodejs",
              "reactjs",
              "js",
              "typescript",
              "javascript"
          ]
      },
      {
          "title": "Learn Node JS Beginner to Intermediate Level — Free Learning YouTube Videos",
          "pubDate": "2018-10-01 12:30:58",
          "link": "https://medium.com/@tkssharma/learn-node-js-beginner-to-intermediate-level-free-learning-youtube-videos-df79264ed0cf?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/df79264ed0cf",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/1000/1*fsseXIPGEhwmg6kfgXyIjA.jpeg",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*fsseXIPGEhwmg6kfgXyIjA.jpeg\"></figure><a href=\"https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href\">https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href</a><a href=\"https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href\">https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href</a><a href=\"https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href\">https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href</a><a href=\"https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href\">https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href</a><a href=\"https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href\">https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href</a><a href=\"https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href\">https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href</a><a href=\"https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href\">https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href</a><a href=\"https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href\">https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href</a><a href=\"https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href\">https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href</a><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df79264ed0cf\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1000/1*fsseXIPGEhwmg6kfgXyIjA.jpeg\"></figure><a href=\"https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href\">https://medium.com/media/888c14589fd85f1cb4b16041febfd9a1/href</a><a href=\"https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href\">https://medium.com/media/17a3bd976c56e5e5c44f473d9160701e/href</a><a href=\"https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href\">https://medium.com/media/d573930c2e0a1f2028bbf9e223929ea3/href</a><a href=\"https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href\">https://medium.com/media/b683907cf404a42dbd512920e83dcdd2/href</a><a href=\"https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href\">https://medium.com/media/efffcff93ccc36a71418c9dc93b32fa5/href</a><a href=\"https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href\">https://medium.com/media/f5a977fa4f68e9dfb78c113ff490369f/href</a><a href=\"https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href\">https://medium.com/media/1d6b25a7822929a71ff95e661c49c5d6/href</a><a href=\"https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href\">https://medium.com/media/5ab7444ea82748143c3ddcfa4c0fd418/href</a><a href=\"https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href\">https://medium.com/media/0831ee8bc28fc38fd3127ae37c2d76c5/href</a><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=df79264ed0cf\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "nodejs",
              "node-js-tutorial",
              "learning",
              "javascript",
              "youtube-video"
          ]
      },
      {
          "title": "JavaScript ES6 — write new way",
          "pubDate": "2018-09-25 02:08:29",
          "link": "https://medium.com/@tkssharma/javascript-es6-write-new-way-1dcb7d40952c?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/1dcb7d40952c",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/779/1*67201m2bx5fRSzP2lbXLqA.png",
          "description": "\n<p>JavaScript ES6 brings new syntax and new awesome features to make your code more modern and more readable. It allows you to write less code and do more. ES6 introduces us to many great features like arrow functions, template strings, class destruction, Modules… and more. Let’s take a look.</p>\n<h3>const and let</h3>\n<p>const is a new keyword in ES6 for declaring variables. const is more powerful than var. Once used, the variable can’t be reassigned. In other words, it’s an <strong>immutable variable </strong>except when it used with objects.</p>\n<p>This is really useful for targeting the selectors. For example, when we have a single button that fires an event, or when you want to select an HTML element in JavaScript, use const instead of var. This is because var is ‘hoisted’. It’s always preferable to use const when don’t want to reassign the variable .</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/779/1*67201m2bx5fRSzP2lbXLqA.png\"></figure><p>In the code above, const will not change and cannot be reassigned. If you try to give it a new value, it will return you an error.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/561/1*6hP1VNVQ_8Siv6HQyju9cA.png\"></figure><p>let can be reassigned and take new value. It creates a <strong>mutable variable</strong>.</p>\n<p>let is the same as const in that both are blocked-scope. It means that the variable is only available within its scope.</p>\n<h3>Arrow functions</h3>\n<p>The arrow function is really awesome, and makes your code more readable, more structured, and look like modern code. Instead of using this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/763/1*fjf4cc0kHb27cRlnSrmwcQ.png\"></figure><p>Use this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*ol3OyEl4zCwGdLT5OOmyRg.png\"></figure><p>As you see, the arrow function seems more readable and clean! You won’t need to use the old syntax anymore.</p>\n<p>Also, you can use Arrow function with map, filter, and reduce<strong> </strong>built-in functions.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/943/1*ryJby1pq8wA3EyIp1sRNTQ.png\"></figure><p>The map function with arrows looks more clear and readable than map in ES5. With ES6 you can write shorter and smarter code. You can use the same with filter and reduce.</p>\n<h3>Template Literals</h3>\n<p>Template literals or template strings are pretty cool. We don’t have to use the plus (+) operator to concatenate strings, or when we want to use a variable inside a string.</p>\n<p>The old syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/925/1*RxqfDIe2jNG4E1KUD3Mw-w.png\"></figure><p>With new ES6 syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/924/1*16Yxl9wpSuttbJMuFsiNYA.png\"></figure><p>So simple! It’s a really huge difference between the old syntax and ES6. When playing with strings, the literal string in ES6 looks more organized and well structured than ES5.</p>\n<h3>Default parameters</h3>\n<p>When I work in PHP, I usually use default parameters. These allow you to define a parameter in advance.</p>\n<p>So, when you forget to write the parameter, it won’t return an undefined error because the parameter is already defined in the default. So when you run your function with a missed parameter, it will take the value of the default parameter, and it will not return an error!</p>\n<p>Look at this example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*YWalapv4SCVHEjp32G6SOQ.png\"></figure><p>The function above returns undefined because we forgot to give it the second parameter.</p>\n<p>But if we used the default parameter, it won’t return undefined, and it will use its value when we forget to assign a parameter!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/907/1*PYEr_IMC1Uu6m4VFETEfRw.png\"></figure><p>As you see, the function returns a value even though we missed the second parameter. Now with the default parameter, we can handle the error in advance.</p>\n<h3>Array and object destructing</h3>\n<p>Destruction makes the assignment of the values of an array or object to the new variable easier.</p>\n<p>The old syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*-_gztZYidNjUmczN03vHLg.png\"></figure><p>With ES6 syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/703/1*xBodgoxrytIjNxXU42QTng.png\"></figure><p>With ES5, we have to assign each value to each variable. With ES6, we just put our values within curly brackets to get any property of the object.</p>\n<p>Note:<strong> </strong>if you assign a variable that is not identical to the name of property, it will return undefined. For example, if the name of the property is name and we assign it to a username<strong> </strong>variable,<strong> </strong>it will return undefined.</p>\n<p>We always have to name the variable the same as the name of the property. But in case we want to rename the variable, we can use the colon : instead.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*p1IcVKmbO5pVANRn3kATKA.png\"></figure><p>For the array, we use the same syntax as the object. We have just to replace the curly brackets with square brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*zXKJpPbOh-T-0EYDjRS7-g.png\"></figure><h3>Import and export</h3>\n<p>Using import and export in your JavaScript application makes it more powerful. They allow you to create separate and reusable components.</p>\n<p>If you are familiar with any JavaScript MVC framework, you will see that they use import and export to handle the components most of the time. So how do they really work?</p>\n<p>It is simple! export allows you to export a module to be used in another JavaScript component. We use import to import that module to use it in our component.</p>\n<p>For example, we have two files. The first is named detailComponent.js<strong> </strong>and the second is named<strong> </strong>homeComponent.js.</p>\n<p>In detailComponent.js<strong> </strong>we are going to export the detail function.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*8d92-RWEx0ygfE22dVWGDA.png\"></figure><p>And if we want to use this function in homeComponent.js,<strong> </strong>we will just use import.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*9BZyWlYn4AYUiJxHjGRSlg.png\"></figure><p>If we want to import more than one module, we just put them within curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VYV52kLrNzZB5-hvartRxA.png\"></figure><p>So cool, isn’t it?!</p>\n<h3>Promises</h3>\n<p>Promises are a new feature of ES6. It’s a method to write asynchronous code. It can be used when, for example, we want to fetch data from an API, or when we have a function that takes time to be executed. Promises make it easier to solve the problem, so let’s create our first Promise!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1011/1*RPGNKVoCRxnA-uVv9Kl4mA.png\"></figure><p>If you log your console, it will return a Promise. So, if we want to execute a function after data is fetched, we will use a Promise. The Promise takes two parameters: resolve and reject to handle an expected error.</p>\n<p>Note: the fetch function returns a Promise itself!</p>\n<pre><em>const</em> url='https://jsonplaceholder.typicode.com/posts';</pre>\n<pre><em>const</em> getData=(<em>url</em>)<em>=&gt;</em>{<br>return fetch(url);<br>}</pre>\n<pre>getData(url).<br>then(<em>data=&gt;</em> data.json()).<br>then(<em>result=&gt;</em> <em>console</em>.log(result));</pre>\n<p>Now if you log your console it will return an array of data.</p>\n<h3>Rest parameter and Spread operator</h3>\n<p><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Functions/rest_parameters\">The rest parameter</a>s are used to get the argument of an array, and return a new array.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/961/1*8ohFXBJT4xFXwAScL5fy_g.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/976/1*v_5auLvegq0LqezITsIJyw.png\"></figure><p>The spread operator has the same syntax as the rest parameter, but the spread operator takes the Array itself and not just the arguments. We can use the Spread parameter to get the values of an Array, instead of using a for loop or any other method.</p>\n<pre><em>const</em> arr=['said',20,'JavaScript enthusiast','Hi','Said','How are you?'];</pre>\n<pre><em>const</em> Func=(...anArray)<em>=&gt;</em>{<br>return anArray;<br>}<br><em>console</em>.log(Func(arr));<br>//output  [\"said\", 20, \"JavaScript enthusiast\", \"Hi\", \"Said\", \"How are you?\"</pre>\n<h3>Classes</h3>\n<p>Classes are the core of object oriented programming (OOP). They make your code more secure and encapsulated. Using classes gives your code a nice structure and keeps it oriented.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/535/1*ht30N18_fdWnRa5qKsZwvg.png\"></figure><p>To create a class, use the class keyword followed by the name of the class with two curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/914/1*GqEJkUDBPtZ_uxx0hlDMNg.png\"></figure><p>Now we can access the class methods and properties using the newkeyword.</p>\n<pre><em>class</em> myClass{<br><em>constructor</em>(<em>name</em>,<em>age</em>){<br>    this.name=name;<br>    this.age=age;<br>}<br>}<br><em>const</em> Home= new myClass(\"said\",20);</pre>\n<pre><em>console</em>.log(Home.name)//  said</pre>\n<p>To inherit from another class, use the extends keyword followed by the name of the class you want to inherit from.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/937/1*2toiRjEKo_jhig8_WAbAVg.png\"></figure><p>You can learn more about Classes<strong> </strong><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Classes\">here</a>.</p>\n<p>ES6 has other amazing features — you can explore them <a href=\"http://es6-features.org/\">here</a>.</p>\n<h3>Conclusion</h3>\n<p>I hope you guys found this article useful, and I hope I was able to introduce you some of the ES6 features</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1dcb7d40952c\" width=\"1\" height=\"1\">\n",
          "content": "\n<p>JavaScript ES6 brings new syntax and new awesome features to make your code more modern and more readable. It allows you to write less code and do more. ES6 introduces us to many great features like arrow functions, template strings, class destruction, Modules… and more. Let’s take a look.</p>\n<h3>const and let</h3>\n<p>const is a new keyword in ES6 for declaring variables. const is more powerful than var. Once used, the variable can’t be reassigned. In other words, it’s an <strong>immutable variable </strong>except when it used with objects.</p>\n<p>This is really useful for targeting the selectors. For example, when we have a single button that fires an event, or when you want to select an HTML element in JavaScript, use const instead of var. This is because var is ‘hoisted’. It’s always preferable to use const when don’t want to reassign the variable .</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/779/1*67201m2bx5fRSzP2lbXLqA.png\"></figure><p>In the code above, const will not change and cannot be reassigned. If you try to give it a new value, it will return you an error.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/561/1*6hP1VNVQ_8Siv6HQyju9cA.png\"></figure><p>let can be reassigned and take new value. It creates a <strong>mutable variable</strong>.</p>\n<p>let is the same as const in that both are blocked-scope. It means that the variable is only available within its scope.</p>\n<h3>Arrow functions</h3>\n<p>The arrow function is really awesome, and makes your code more readable, more structured, and look like modern code. Instead of using this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/763/1*fjf4cc0kHb27cRlnSrmwcQ.png\"></figure><p>Use this:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/799/1*ol3OyEl4zCwGdLT5OOmyRg.png\"></figure><p>As you see, the arrow function seems more readable and clean! You won’t need to use the old syntax anymore.</p>\n<p>Also, you can use Arrow function with map, filter, and reduce<strong> </strong>built-in functions.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/943/1*ryJby1pq8wA3EyIp1sRNTQ.png\"></figure><p>The map function with arrows looks more clear and readable than map in ES5. With ES6 you can write shorter and smarter code. You can use the same with filter and reduce.</p>\n<h3>Template Literals</h3>\n<p>Template literals or template strings are pretty cool. We don’t have to use the plus (+) operator to concatenate strings, or when we want to use a variable inside a string.</p>\n<p>The old syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/925/1*RxqfDIe2jNG4E1KUD3Mw-w.png\"></figure><p>With new ES6 syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/924/1*16Yxl9wpSuttbJMuFsiNYA.png\"></figure><p>So simple! It’s a really huge difference between the old syntax and ES6. When playing with strings, the literal string in ES6 looks more organized and well structured than ES5.</p>\n<h3>Default parameters</h3>\n<p>When I work in PHP, I usually use default parameters. These allow you to define a parameter in advance.</p>\n<p>So, when you forget to write the parameter, it won’t return an undefined error because the parameter is already defined in the default. So when you run your function with a missed parameter, it will take the value of the default parameter, and it will not return an error!</p>\n<p>Look at this example:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/915/1*YWalapv4SCVHEjp32G6SOQ.png\"></figure><p>The function above returns undefined because we forgot to give it the second parameter.</p>\n<p>But if we used the default parameter, it won’t return undefined, and it will use its value when we forget to assign a parameter!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/907/1*PYEr_IMC1Uu6m4VFETEfRw.png\"></figure><p>As you see, the function returns a value even though we missed the second parameter. Now with the default parameter, we can handle the error in advance.</p>\n<h3>Array and object destructing</h3>\n<p>Destruction makes the assignment of the values of an array or object to the new variable easier.</p>\n<p>The old syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/750/1*-_gztZYidNjUmczN03vHLg.png\"></figure><p>With ES6 syntax:</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/703/1*xBodgoxrytIjNxXU42QTng.png\"></figure><p>With ES5, we have to assign each value to each variable. With ES6, we just put our values within curly brackets to get any property of the object.</p>\n<p>Note:<strong> </strong>if you assign a variable that is not identical to the name of property, it will return undefined. For example, if the name of the property is name and we assign it to a username<strong> </strong>variable,<strong> </strong>it will return undefined.</p>\n<p>We always have to name the variable the same as the name of the property. But in case we want to rename the variable, we can use the colon : instead.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/856/1*p1IcVKmbO5pVANRn3kATKA.png\"></figure><p>For the array, we use the same syntax as the object. We have just to replace the curly brackets with square brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/935/1*zXKJpPbOh-T-0EYDjRS7-g.png\"></figure><h3>Import and export</h3>\n<p>Using import and export in your JavaScript application makes it more powerful. They allow you to create separate and reusable components.</p>\n<p>If you are familiar with any JavaScript MVC framework, you will see that they use import and export to handle the components most of the time. So how do they really work?</p>\n<p>It is simple! export allows you to export a module to be used in another JavaScript component. We use import to import that module to use it in our component.</p>\n<p>For example, we have two files. The first is named detailComponent.js<strong> </strong>and the second is named<strong> </strong>homeComponent.js.</p>\n<p>In detailComponent.js<strong> </strong>we are going to export the detail function.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/780/1*8d92-RWEx0ygfE22dVWGDA.png\"></figure><p>And if we want to use this function in homeComponent.js,<strong> </strong>we will just use import.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/803/1*9BZyWlYn4AYUiJxHjGRSlg.png\"></figure><p>If we want to import more than one module, we just put them within curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/1*VYV52kLrNzZB5-hvartRxA.png\"></figure><p>So cool, isn’t it?!</p>\n<h3>Promises</h3>\n<p>Promises are a new feature of ES6. It’s a method to write asynchronous code. It can be used when, for example, we want to fetch data from an API, or when we have a function that takes time to be executed. Promises make it easier to solve the problem, so let’s create our first Promise!</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1011/1*RPGNKVoCRxnA-uVv9Kl4mA.png\"></figure><p>If you log your console, it will return a Promise. So, if we want to execute a function after data is fetched, we will use a Promise. The Promise takes two parameters: resolve and reject to handle an expected error.</p>\n<p>Note: the fetch function returns a Promise itself!</p>\n<pre><em>const</em> url='https://jsonplaceholder.typicode.com/posts';</pre>\n<pre><em>const</em> getData=(<em>url</em>)<em>=&gt;</em>{<br>return fetch(url);<br>}</pre>\n<pre>getData(url).<br>then(<em>data=&gt;</em> data.json()).<br>then(<em>result=&gt;</em> <em>console</em>.log(result));</pre>\n<p>Now if you log your console it will return an array of data.</p>\n<h3>Rest parameter and Spread operator</h3>\n<p><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Functions/rest_parameters\">The rest parameter</a>s are used to get the argument of an array, and return a new array.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/961/1*8ohFXBJT4xFXwAScL5fy_g.png\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/976/1*v_5auLvegq0LqezITsIJyw.png\"></figure><p>The spread operator has the same syntax as the rest parameter, but the spread operator takes the Array itself and not just the arguments. We can use the Spread parameter to get the values of an Array, instead of using a for loop or any other method.</p>\n<pre><em>const</em> arr=['said',20,'JavaScript enthusiast','Hi','Said','How are you?'];</pre>\n<pre><em>const</em> Func=(...anArray)<em>=&gt;</em>{<br>return anArray;<br>}<br><em>console</em>.log(Func(arr));<br>//output  [\"said\", 20, \"JavaScript enthusiast\", \"Hi\", \"Said\", \"How are you?\"</pre>\n<h3>Classes</h3>\n<p>Classes are the core of object oriented programming (OOP). They make your code more secure and encapsulated. Using classes gives your code a nice structure and keeps it oriented.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/535/1*ht30N18_fdWnRa5qKsZwvg.png\"></figure><p>To create a class, use the class keyword followed by the name of the class with two curly brackets.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/914/1*GqEJkUDBPtZ_uxx0hlDMNg.png\"></figure><p>Now we can access the class methods and properties using the newkeyword.</p>\n<pre><em>class</em> myClass{<br><em>constructor</em>(<em>name</em>,<em>age</em>){<br>    this.name=name;<br>    this.age=age;<br>}<br>}<br><em>const</em> Home= new myClass(\"said\",20);</pre>\n<pre><em>console</em>.log(Home.name)//  said</pre>\n<p>To inherit from another class, use the extends keyword followed by the name of the class you want to inherit from.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/937/1*2toiRjEKo_jhig8_WAbAVg.png\"></figure><p>You can learn more about Classes<strong> </strong><a href=\"https://developer.mozilla.org/ar/docs/Web/JavaScript/Reference/Classes\">here</a>.</p>\n<p>ES6 has other amazing features — you can explore them <a href=\"http://es6-features.org/\">here</a>.</p>\n<h3>Conclusion</h3>\n<p>I hope you guys found this article useful, and I hope I was able to introduce you some of the ES6 features</p>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=1dcb7d40952c\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript"
          ]
      },
      {
          "title": "Node JS Interview Question — Set #05",
          "pubDate": "2018-09-13 15:57:50",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-05-3df44d32d3a3?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/3df44d32d3a3",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question — Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question — Set #03</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-04-b3ea7567675f\">Node JS Interview Question — Set #04</a></li>\n</ul>\n<h3>Question 41</h3>\n<p>How to prevent Unhandled Exception in Node JS and if they are occurring how to handle them</p>\n<p>Node.js event loop runs on a single thread and uncaught exceptions are critical issue and need to be aware of when developing applications.</p>\n<p>Silently Handling Exceptions</p>\n<p>Most of the people let node.js server(s) silently swallow up the errors.</p>\n<p>Silently handling the exception</p>\n<pre>process.on(‘uncaughtException’, <strong>function</strong> (err) {<br> console.log(err);<br>});</pre>\n<p>This is bad, it will work but:</p>\n<p>In this case Root cause of problem will remains unknown, as such will not contribute to resolution of what caused the Exception (Error ).</p>\n<p>In case of node application having database connection ( pool ) which gets closed for some reason will result in constant propagation of errors, meaning that server will be running but it will not reconnect to db. So you should write a code which can manage and do not generate Unhandled exception and for debugging purpose you can caught those process and identify the cause.</p>\n<h3>Question 42</h3>\n<p>How to convert callback based library to promise based library so instead of writing callback we can write promises.</p>\n<p>This is an important aspect and this is being used for many library like redis-client, mysql-client, we can use bluebird.promisifyAll to convert any callback based library to promise based.</p>\n<pre>db.notification.email.find({subject: ‘promisify callback’}, (error, result) =&gt; {<br><strong>if</strong> (error) {<br> console.log(error);<br> }<br> // normal code here<br>});</pre>\n<p>It is using bluebird’s promisifyAll method to promisify what is conventionally callback-based library.</p>\n<p>After applying these change promise-based methods names wil have Async appended to them:</p>\n<pre><strong>let</strong> email = bluebird.promisifyAll(db.notification.email);<br>email.findAsync({subject: ‘promisify callback’}).then(result =&gt; {<br> // normal code here<br>})<br>.catch(console.error);</pre>\n<p>Same thing can be done for redis library which is callback based library</p>\n<pre><strong>const</strong> redis = require(‘redis’);<br>bluebird.promisifyAll(redis);<br>client.getAsync(‘data:key’).then(<strong>function</strong>(res) {<br> console.log(res); // =&gt; ‘bar’<br>});</pre>\n<h3>Question 43</h3>\n<p>What is global object in Node JS how to add object to global variable &amp; how it’s different from browser global environment.</p>\n<p>In browsers when we do console.log(this) it represent the window object and in node JS the global scope of a module is the module itself, so when you define a variable in the global scope of your node JS module, it will be local to this module.</p>\n<p>In node js global represents global scope only you can add variable in global object it will be available on node js process and can be accessed in any other local module.</p>\n<p>We can add some common configuration to global object like mysql connection object or logger object as we will using these objects on different places in application.</p>\n<pre><strong>const</strong> mysql = require(‘mysql2’);<br>global.connection = <strong>null</strong>;<br><strong>try</strong> {<br> global.connection = mysql.createConnection(global.configuration.db);<br>} <strong>catch</strong> (err) {<br><strong>throw</strong> Error(err);<br>}<br>global.connection.connect((err) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br>});<br>global.connection.on(‘error’, (err) =&gt; {<br> logger.info(`Cannot establish a connection with the database (${err.code})`);<br>});<br>module.exports = global.connection;</pre>\n<p>global&lt;Object&gt; The global namespace object.</p>\n<p>In browsers, the top-level scope is the global scope. That means that in browsers if you’re in the global scope var something will define a global variable. In Node.js this is different. The top-level scope is not the global scope; var something inside an Node.js module will be local to that module.</p>\n<h3>Question 44</h3>\n<p>What is circular dependency in modules while executing Node JS and how to fix this issue</p>\n<p>In this example there two file which are doing require each other foo file one is requiring file and same thing is happening with bar.js</p>\n<p>It’s like circular dependency &amp; these is no issue it will compile as expected but at run time behaviour is totally different then expected.</p>\n<p>foo is being imported in bar module &amp; bar is being imported in foo module</p>\n<p>The important part is it is being done synchronously,no module.export calls have yet been made!. So when bar.js was required intofoo.js, it immediately tried to require bar.js back into itself, but foo.js hasn’t been exported yet. The result is that foo.js only has a reference to an empty object!</p>\n<p>This is called circular dependency and you should import export modules not in circular way.</p>\n<p><a href=\"https://www.npmjs.com/package/madge\">https://www.npmjs.com/package/madge</a> can be used to detect such kind of circular dependencies</p>\n<pre>// hello.js<br><strong>var</strong> bar = require(‘./foo.js’); <br>console.log(‘class b:’, bar);<br><strong>var</strong> foo = <strong>function</strong>() { <br><strong>this</strong>.bInstance = bar();<br><strong>this</strong>.property = 5;<br>}<br>module.exports = foo;</pre>\n<pre>// hello1.js<br><strong>var</strong> foo = require(‘./foo.js’);<br><strong>var</strong> bar = <strong>function</strong>() {}<br>bar.prototype.doSomethingLater = <strong>function</strong>() { <br> console.log(foo.property);<br>}<br>module.exports = bar;</pre>\n<h3>Question 45</h3>\n<p>What is the Node JS require cache and how to invalidate it</p>\n<p>when we require module in one file it gets cached in node js and its gets passed to another module requiring same module again this is require cache which node js maintain in node js execution cycle. It can also be invalidated when needed</p>\n<p>and Yes, you can access the cache via require.cache[moduleName] where moduleName is the name of the module you wish to access. Deleting an entry by calling delete require.cache[moduleName] will cause require to load the actual file.</p>\n<p>So from the above description we can say yes, you can invalidate cache.</p>\n<p>The cache is stored in object require.cache which you can access according to filenames (e.g. — ~/home/index.js as opposed to ./home which you would use in a require(‘./home’) statement).</p>\n<h3>Question 46</h3>\n<p>What is the best way to add security to apis in Node JS application, what are some well known module should can be used.</p>\n<p>For security we should take care of lot of things but here let’s see how we can make apis more secure</p>\n<ul>\n<li>Don’t use deprecated or vulnerable versions of Express</li>\n<li>Use latest version of NPM &amp; run ( npm audit )</li>\n<li>Use Helmet, csurf module for adding security</li>\n<li>Add security to the cookies by signing cookies or making them secure.</li>\n<li>Add rate limiter to prevent brute force attack</li>\n<li>Send Security HTTP Headers</li>\n<li>Prevent SQL injection in your code.</li>\n<li>APIs should be running on HTTPS</li>\n<li>run npm audit regularly</li>\n</ul>\n<p><strong>Secure Express.js Sessions and Cookies</strong></p>\n<p>Session cookie name reveals your application’s internals</p>\n<p>Revealing what technologies you are using for your application is one of the key things that you should not do. If an attacker knows what kind of technology you are using, he can drastically reduce his scope in finding vulnerable components in your application. There are a couple of ways which reveals internal implementation details of your application. One of them is the session cookie name of your application.</p>\n<p><strong>Make cookies more secure</strong></p>\n<p>When you use cookies in your application make sure to add HttpOnly flag to the cookies. Adding HttpOnly flag makes sure that no external script other than an HTTP connection can fetch cookies in your application. This is a good protection mechanism against cross site scripting attacks where attackers read your cookies through malicious scripts.</p>\n<p><strong>Signing cookies</strong></p>\n<p>Signing cookies provide prevention of cookie forging. A signed cookie is a value which has the cookie value as well as a digital signature attached to itself. Once the cookie is received from the server end, the server will validate the integrity of the cookie by validating its signature</p>\n<p><a href=\"https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971\">https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971</a></p>\n<pre>app.disable(‘x-powered-by’);<br> app.use(helmet());<br> app.use(helmet.noCache({ noEtag: <strong>true</strong> })); // set Cache-Control header<br> app.use(helmet.noSniff()); // set X-Content-Type-Options header<br> app.use(helmet.frameguard()); // set X-Frame-Options header<br> app.use(helmet.xssFilter()); // set X-XSS-Protection header<br> app.enable(‘trust proxy’, [‘loopback’, ‘linklocal’, ‘uniquelocal’]);<br> app.use(expressSession({<br> name: ‘SESS_ID’,<br> secret: configServer.SESSION_SECRET,<br> proxy: <strong>true</strong>,<br> resave: <strong>true</strong>,<br> saveUninitialized: <strong>true</strong>,<br> }));</pre>\n<h3>Question 47</h3>\n<p>How error handling can be done in Node JS api app like handling api errors.</p>\n<p>Error handling is a feature of express which can be done by using some middleware. Error can be some defined errors codes or some errors are runtime errors coming from database, redis or some other data store.</p>\n<p>Server Errors : There are many error codes which are returned from API like 301,404,403 or 500.</p>\n<p>API Error Codes : In APIs we can return error codes with our own message to notify client about situation at server side like “user data not found”, These are some known errors which we are throwing explicitly from code but what should we do with runtime errors like some database connection issue, some column is missing or query is not correctly written.</p>\n<pre>router.get(‘/users/:id’, <strong>function</strong>(req, res, next) {<br><strong>var</strong> user = users.getUserById(req.params.id);<br><strong>if</strong> (user == <strong>null</strong> || user == ‘undefined’) { <br> res.status(400).json({‘message’ : ‘user not found’});<br> }<br>});</pre>\n<p>For handling such unknown runtime errors we can just create middleware and this middleware will have error object additional which will give us detail about what error occured with stack trace &amp; status code.</p>\n<p>Create error handler middleware as global Middleware and register this middleware with app instance.</p>\n<pre><strong>class</strong> <strong>errorHandlers</strong> {<br><strong>static</strong> internalServerError(err, req, res, next) {<br> res.status(500).json({<br> success: <strong>false</strong>,<br> message: err.message,<br> error: err.stack ,<br> }); <br> }<br>}<br>module.exports = errorHandlers;<br>// in your server.js<br>app.use(errorHandlers.internalServerError);</pre>\n<h3>Question 48</h3>\n<p>How to create basic middleware and how to register middleware in application.</p>\n<p>Middleware functions are simple javascript functions that have access to the request response object and the next function during application request response cycle. In middleware we do pre and post processing with request and response object.</p>\n<p>We can talk about basic example of pre processing requests like</p>\n<ol>\n<li>HTTP post method should not have empty body an example of pre processing of request</li>\n<li>HTTP Methods should have application/json as content type.</li>\n<li>Secured routes should have some token available in request for checking authorisation. This can be done using some middleware which will check request for protected routes and validate if available token in request is valid.</li>\n</ol>\n<p>Middleware function should call next function to execute or move to next middleware.</p>\n<p>Middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function otherwise, the request will be left stuck or hanging in middle.</p>\n<p>we use middleware to do pre processing and post processing for request processing.</p>\n<p>We can have simple example of Express application. We create an express application which is sending response “hello world” on “/” route request and serving on HTTP Port 3000.</p>\n<pre><strong>var</strong> express = require(‘express’)<br><strong>var</strong> app = express()</pre>\n<pre>app.get(‘/’, <strong>function</strong> (req, res) {<br> res.send(‘Hello World!’)<br>})</pre>\n<pre><strong>app.listen(3000)</strong></pre>\n<p><strong>Middleware function logger example</strong></p>\n<p>Here is a simple example of a middleware function called “logger”. This function will be logging message ‘LOGGED’ on each and every request as we have registered this middleware on app instance by doing app.use(middleware).</p>\n<pre><strong>var</strong> myLogger = <strong>function</strong> (req, res, next) {<br> console.log(‘LOGGED’)<br> next()<br>}<br>// this is how we register middleware<br>app.use(myLogger)</pre>\n<p>We can add middleware to a route itself instead of doing it on express instance and making that middleware global for each and every request, in this case this middleware will be available for this route only.</p>\n<p>We do have global middleware which we register on app instance like body parser which is used to extract req body from coming request from client.</p>\n<pre>// parse application/x-www-form-urlencoded<br>app.use(bodyParser.urlencoded({ extended: <strong>false</strong> })</pre>\n<pre>// parse application/json<br>app.use(bodyParser.json())</pre>\n<pre>Example of middleware registered only to a route.</pre>\n<pre><strong>var</strong> middleware = <strong>function</strong>(req,res,next){<br> next()<br>}<br>app.get(‘/’, middleware, <strong>function</strong> (req, res) {<br> res.send(‘Hello World!’)<br>})</pre>\n<h3>Question 49</h3>\n<p>Can you explain how logging can be done in Node JS application api logging or simple logging in some file</p>\n<p>logging is important aspect of node js programming, There are different modules available in node js to add logging in node js application</p>\n<p>Logging is needed in Node.js to capture bugs during application runtime.</p>\n<p>logging is needed because we want to :</p>\n<ol>\n<li>To have a better understanding of how your applications works,</li>\n<li>To discover what errors you may encounter runtime.</li>\n<li>To find out if your services are running properly without unhandled errors.</li>\n</ol>\n<p>winston is important module which you can have for logging purpose. Winston is a multi-transport async logging library for Node.js. When i say multi transport means i can have different medium to manage my logs.</p>\n<ol>\n<li>Storing logs on files with custom log format.</li>\n<li>Pushing logs on console.</li>\n<li>Sending logs to any another TCP channel.</li>\n<li>Winston has different log levels and different format can be specified for logging</li>\n</ol>\n<p>You can add winston to your project by installing it:</p>\n<p><strong>npm install winston — save</strong></p>\n<p>Once you have it, you can add winston to your project this way:</p>\n<pre>const winston = require(‘winston’);<br>const logger = new winston.Logger({<br> transports: [<br> new winston.transports.File(options.file),<br> new winston<br> .transports<br> .Console({}),<br> ],<br> exceptionHandlers: [<br> // new winston.transports.File(options.errorLog)<br> ],<br> exitOnError: false, // do not exit on handled exceptions<br>});</pre>\n<pre>// create a stream object with a ‘write’ function that will be used by `morgan`<br>logger.stream = {<br> write(message, encoding) {<br> logger.info(message);<br> }<br>};<br>module.exports = logger;</pre>\n<h3>Question 50</h3>\n<p>How to monitor Node JS process and api transactions by using any tool or library ?</p>\n<p>There are many tools available which can provide real time transaction monitoring and logging of apis like keymatrics and newrelic tools which gives you in detail knowledge about node js process status like memory consumption and time taken.</p>\n<p>These tools are also being used for performance monitoring of APIs</p>\n<p>Newrelic &amp; keymatrics are industry standards and being used in many enterprises to check and monitor Node js process</p>\n<p><a href=\"https://rpm.newrelic.com/\">https://rpm.newrelic.com</a></p>\n<p><a href=\"http://pm2.io/\">http://pm2.io/</a></p>\n<p>Tools for Node js process Monitoring</p>\n<ol>\n<li>appdynamics</li>\n<li>nodemon, forever modules to run process in background without monitoring.</li>\n<li>newRelic gives detailed monitoring statics.</li>\n<li>keymetrics is PM2 based tool which shows statics of individual instance and make application highly available. PM2 gives advantages of having multiple instances of application on system so we can use multi-core system efficiently.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OhKB8whwauyV8y6J\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3df44d32d3a3\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question — Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question — Set #03</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-04-b3ea7567675f\">Node JS Interview Question — Set #04</a></li>\n</ul>\n<h3>Question 41</h3>\n<p>How to prevent Unhandled Exception in Node JS and if they are occurring how to handle them</p>\n<p>Node.js event loop runs on a single thread and uncaught exceptions are critical issue and need to be aware of when developing applications.</p>\n<p>Silently Handling Exceptions</p>\n<p>Most of the people let node.js server(s) silently swallow up the errors.</p>\n<p>Silently handling the exception</p>\n<pre>process.on(‘uncaughtException’, <strong>function</strong> (err) {<br> console.log(err);<br>});</pre>\n<p>This is bad, it will work but:</p>\n<p>In this case Root cause of problem will remains unknown, as such will not contribute to resolution of what caused the Exception (Error ).</p>\n<p>In case of node application having database connection ( pool ) which gets closed for some reason will result in constant propagation of errors, meaning that server will be running but it will not reconnect to db. So you should write a code which can manage and do not generate Unhandled exception and for debugging purpose you can caught those process and identify the cause.</p>\n<h3>Question 42</h3>\n<p>How to convert callback based library to promise based library so instead of writing callback we can write promises.</p>\n<p>This is an important aspect and this is being used for many library like redis-client, mysql-client, we can use bluebird.promisifyAll to convert any callback based library to promise based.</p>\n<pre>db.notification.email.find({subject: ‘promisify callback’}, (error, result) =&gt; {<br><strong>if</strong> (error) {<br> console.log(error);<br> }<br> // normal code here<br>});</pre>\n<p>It is using bluebird’s promisifyAll method to promisify what is conventionally callback-based library.</p>\n<p>After applying these change promise-based methods names wil have Async appended to them:</p>\n<pre><strong>let</strong> email = bluebird.promisifyAll(db.notification.email);<br>email.findAsync({subject: ‘promisify callback’}).then(result =&gt; {<br> // normal code here<br>})<br>.catch(console.error);</pre>\n<p>Same thing can be done for redis library which is callback based library</p>\n<pre><strong>const</strong> redis = require(‘redis’);<br>bluebird.promisifyAll(redis);<br>client.getAsync(‘data:key’).then(<strong>function</strong>(res) {<br> console.log(res); // =&gt; ‘bar’<br>});</pre>\n<h3>Question 43</h3>\n<p>What is global object in Node JS how to add object to global variable &amp; how it’s different from browser global environment.</p>\n<p>In browsers when we do console.log(this) it represent the window object and in node JS the global scope of a module is the module itself, so when you define a variable in the global scope of your node JS module, it will be local to this module.</p>\n<p>In node js global represents global scope only you can add variable in global object it will be available on node js process and can be accessed in any other local module.</p>\n<p>We can add some common configuration to global object like mysql connection object or logger object as we will using these objects on different places in application.</p>\n<pre><strong>const</strong> mysql = require(‘mysql2’);<br>global.connection = <strong>null</strong>;<br><strong>try</strong> {<br> global.connection = mysql.createConnection(global.configuration.db);<br>} <strong>catch</strong> (err) {<br><strong>throw</strong> Error(err);<br>}<br>global.connection.connect((err) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br>});<br>global.connection.on(‘error’, (err) =&gt; {<br> logger.info(`Cannot establish a connection with the database (${err.code})`);<br>});<br>module.exports = global.connection;</pre>\n<p>global&lt;Object&gt; The global namespace object.</p>\n<p>In browsers, the top-level scope is the global scope. That means that in browsers if you’re in the global scope var something will define a global variable. In Node.js this is different. The top-level scope is not the global scope; var something inside an Node.js module will be local to that module.</p>\n<h3>Question 44</h3>\n<p>What is circular dependency in modules while executing Node JS and how to fix this issue</p>\n<p>In this example there two file which are doing require each other foo file one is requiring file and same thing is happening with bar.js</p>\n<p>It’s like circular dependency &amp; these is no issue it will compile as expected but at run time behaviour is totally different then expected.</p>\n<p>foo is being imported in bar module &amp; bar is being imported in foo module</p>\n<p>The important part is it is being done synchronously,no module.export calls have yet been made!. So when bar.js was required intofoo.js, it immediately tried to require bar.js back into itself, but foo.js hasn’t been exported yet. The result is that foo.js only has a reference to an empty object!</p>\n<p>This is called circular dependency and you should import export modules not in circular way.</p>\n<p><a href=\"https://www.npmjs.com/package/madge\">https://www.npmjs.com/package/madge</a> can be used to detect such kind of circular dependencies</p>\n<pre>// hello.js<br><strong>var</strong> bar = require(‘./foo.js’); <br>console.log(‘class b:’, bar);<br><strong>var</strong> foo = <strong>function</strong>() { <br><strong>this</strong>.bInstance = bar();<br><strong>this</strong>.property = 5;<br>}<br>module.exports = foo;</pre>\n<pre>// hello1.js<br><strong>var</strong> foo = require(‘./foo.js’);<br><strong>var</strong> bar = <strong>function</strong>() {}<br>bar.prototype.doSomethingLater = <strong>function</strong>() { <br> console.log(foo.property);<br>}<br>module.exports = bar;</pre>\n<h3>Question 45</h3>\n<p>What is the Node JS require cache and how to invalidate it</p>\n<p>when we require module in one file it gets cached in node js and its gets passed to another module requiring same module again this is require cache which node js maintain in node js execution cycle. It can also be invalidated when needed</p>\n<p>and Yes, you can access the cache via require.cache[moduleName] where moduleName is the name of the module you wish to access. Deleting an entry by calling delete require.cache[moduleName] will cause require to load the actual file.</p>\n<p>So from the above description we can say yes, you can invalidate cache.</p>\n<p>The cache is stored in object require.cache which you can access according to filenames (e.g. — ~/home/index.js as opposed to ./home which you would use in a require(‘./home’) statement).</p>\n<h3>Question 46</h3>\n<p>What is the best way to add security to apis in Node JS application, what are some well known module should can be used.</p>\n<p>For security we should take care of lot of things but here let’s see how we can make apis more secure</p>\n<ul>\n<li>Don’t use deprecated or vulnerable versions of Express</li>\n<li>Use latest version of NPM &amp; run ( npm audit )</li>\n<li>Use Helmet, csurf module for adding security</li>\n<li>Add security to the cookies by signing cookies or making them secure.</li>\n<li>Add rate limiter to prevent brute force attack</li>\n<li>Send Security HTTP Headers</li>\n<li>Prevent SQL injection in your code.</li>\n<li>APIs should be running on HTTPS</li>\n<li>run npm audit regularly</li>\n</ul>\n<p><strong>Secure Express.js Sessions and Cookies</strong></p>\n<p>Session cookie name reveals your application’s internals</p>\n<p>Revealing what technologies you are using for your application is one of the key things that you should not do. If an attacker knows what kind of technology you are using, he can drastically reduce his scope in finding vulnerable components in your application. There are a couple of ways which reveals internal implementation details of your application. One of them is the session cookie name of your application.</p>\n<p><strong>Make cookies more secure</strong></p>\n<p>When you use cookies in your application make sure to add HttpOnly flag to the cookies. Adding HttpOnly flag makes sure that no external script other than an HTTP connection can fetch cookies in your application. This is a good protection mechanism against cross site scripting attacks where attackers read your cookies through malicious scripts.</p>\n<p><strong>Signing cookies</strong></p>\n<p>Signing cookies provide prevention of cookie forging. A signed cookie is a value which has the cookie value as well as a digital signature attached to itself. Once the cookie is received from the server end, the server will validate the integrity of the cookie by validating its signature</p>\n<p><a href=\"https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971\">https://medium.com/@tkssharma/secure-node-js-apps-7613973b6971</a></p>\n<pre>app.disable(‘x-powered-by’);<br> app.use(helmet());<br> app.use(helmet.noCache({ noEtag: <strong>true</strong> })); // set Cache-Control header<br> app.use(helmet.noSniff()); // set X-Content-Type-Options header<br> app.use(helmet.frameguard()); // set X-Frame-Options header<br> app.use(helmet.xssFilter()); // set X-XSS-Protection header<br> app.enable(‘trust proxy’, [‘loopback’, ‘linklocal’, ‘uniquelocal’]);<br> app.use(expressSession({<br> name: ‘SESS_ID’,<br> secret: configServer.SESSION_SECRET,<br> proxy: <strong>true</strong>,<br> resave: <strong>true</strong>,<br> saveUninitialized: <strong>true</strong>,<br> }));</pre>\n<h3>Question 47</h3>\n<p>How error handling can be done in Node JS api app like handling api errors.</p>\n<p>Error handling is a feature of express which can be done by using some middleware. Error can be some defined errors codes or some errors are runtime errors coming from database, redis or some other data store.</p>\n<p>Server Errors : There are many error codes which are returned from API like 301,404,403 or 500.</p>\n<p>API Error Codes : In APIs we can return error codes with our own message to notify client about situation at server side like “user data not found”, These are some known errors which we are throwing explicitly from code but what should we do with runtime errors like some database connection issue, some column is missing or query is not correctly written.</p>\n<pre>router.get(‘/users/:id’, <strong>function</strong>(req, res, next) {<br><strong>var</strong> user = users.getUserById(req.params.id);<br><strong>if</strong> (user == <strong>null</strong> || user == ‘undefined’) { <br> res.status(400).json({‘message’ : ‘user not found’});<br> }<br>});</pre>\n<p>For handling such unknown runtime errors we can just create middleware and this middleware will have error object additional which will give us detail about what error occured with stack trace &amp; status code.</p>\n<p>Create error handler middleware as global Middleware and register this middleware with app instance.</p>\n<pre><strong>class</strong> <strong>errorHandlers</strong> {<br><strong>static</strong> internalServerError(err, req, res, next) {<br> res.status(500).json({<br> success: <strong>false</strong>,<br> message: err.message,<br> error: err.stack ,<br> }); <br> }<br>}<br>module.exports = errorHandlers;<br>// in your server.js<br>app.use(errorHandlers.internalServerError);</pre>\n<h3>Question 48</h3>\n<p>How to create basic middleware and how to register middleware in application.</p>\n<p>Middleware functions are simple javascript functions that have access to the request response object and the next function during application request response cycle. In middleware we do pre and post processing with request and response object.</p>\n<p>We can talk about basic example of pre processing requests like</p>\n<ol>\n<li>HTTP post method should not have empty body an example of pre processing of request</li>\n<li>HTTP Methods should have application/json as content type.</li>\n<li>Secured routes should have some token available in request for checking authorisation. This can be done using some middleware which will check request for protected routes and validate if available token in request is valid.</li>\n</ol>\n<p>Middleware function should call next function to execute or move to next middleware.</p>\n<p>Middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function otherwise, the request will be left stuck or hanging in middle.</p>\n<p>we use middleware to do pre processing and post processing for request processing.</p>\n<p>We can have simple example of Express application. We create an express application which is sending response “hello world” on “/” route request and serving on HTTP Port 3000.</p>\n<pre><strong>var</strong> express = require(‘express’)<br><strong>var</strong> app = express()</pre>\n<pre>app.get(‘/’, <strong>function</strong> (req, res) {<br> res.send(‘Hello World!’)<br>})</pre>\n<pre><strong>app.listen(3000)</strong></pre>\n<p><strong>Middleware function logger example</strong></p>\n<p>Here is a simple example of a middleware function called “logger”. This function will be logging message ‘LOGGED’ on each and every request as we have registered this middleware on app instance by doing app.use(middleware).</p>\n<pre><strong>var</strong> myLogger = <strong>function</strong> (req, res, next) {<br> console.log(‘LOGGED’)<br> next()<br>}<br>// this is how we register middleware<br>app.use(myLogger)</pre>\n<p>We can add middleware to a route itself instead of doing it on express instance and making that middleware global for each and every request, in this case this middleware will be available for this route only.</p>\n<p>We do have global middleware which we register on app instance like body parser which is used to extract req body from coming request from client.</p>\n<pre>// parse application/x-www-form-urlencoded<br>app.use(bodyParser.urlencoded({ extended: <strong>false</strong> })</pre>\n<pre>// parse application/json<br>app.use(bodyParser.json())</pre>\n<pre>Example of middleware registered only to a route.</pre>\n<pre><strong>var</strong> middleware = <strong>function</strong>(req,res,next){<br> next()<br>}<br>app.get(‘/’, middleware, <strong>function</strong> (req, res) {<br> res.send(‘Hello World!’)<br>})</pre>\n<h3>Question 49</h3>\n<p>Can you explain how logging can be done in Node JS application api logging or simple logging in some file</p>\n<p>logging is important aspect of node js programming, There are different modules available in node js to add logging in node js application</p>\n<p>Logging is needed in Node.js to capture bugs during application runtime.</p>\n<p>logging is needed because we want to :</p>\n<ol>\n<li>To have a better understanding of how your applications works,</li>\n<li>To discover what errors you may encounter runtime.</li>\n<li>To find out if your services are running properly without unhandled errors.</li>\n</ol>\n<p>winston is important module which you can have for logging purpose. Winston is a multi-transport async logging library for Node.js. When i say multi transport means i can have different medium to manage my logs.</p>\n<ol>\n<li>Storing logs on files with custom log format.</li>\n<li>Pushing logs on console.</li>\n<li>Sending logs to any another TCP channel.</li>\n<li>Winston has different log levels and different format can be specified for logging</li>\n</ol>\n<p>You can add winston to your project by installing it:</p>\n<p><strong>npm install winston — save</strong></p>\n<p>Once you have it, you can add winston to your project this way:</p>\n<pre>const winston = require(‘winston’);<br>const logger = new winston.Logger({<br> transports: [<br> new winston.transports.File(options.file),<br> new winston<br> .transports<br> .Console({}),<br> ],<br> exceptionHandlers: [<br> // new winston.transports.File(options.errorLog)<br> ],<br> exitOnError: false, // do not exit on handled exceptions<br>});</pre>\n<pre>// create a stream object with a ‘write’ function that will be used by `morgan`<br>logger.stream = {<br> write(message, encoding) {<br> logger.info(message);<br> }<br>};<br>module.exports = logger;</pre>\n<h3>Question 50</h3>\n<p>How to monitor Node JS process and api transactions by using any tool or library ?</p>\n<p>There are many tools available which can provide real time transaction monitoring and logging of apis like keymatrics and newrelic tools which gives you in detail knowledge about node js process status like memory consumption and time taken.</p>\n<p>These tools are also being used for performance monitoring of APIs</p>\n<p>Newrelic &amp; keymatrics are industry standards and being used in many enterprises to check and monitor Node js process</p>\n<p><a href=\"https://rpm.newrelic.com/\">https://rpm.newrelic.com</a></p>\n<p><a href=\"http://pm2.io/\">http://pm2.io/</a></p>\n<p>Tools for Node js process Monitoring</p>\n<ol>\n<li>appdynamics</li>\n<li>nodemon, forever modules to run process in background without monitoring.</li>\n<li>newRelic gives detailed monitoring statics.</li>\n<li>keymetrics is PM2 based tool which shows statics of individual instance and make application highly available. PM2 gives advantages of having multiple instances of application on system so we can use multi-core system efficiently.</li>\n</ol>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*OhKB8whwauyV8y6J\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=3df44d32d3a3\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript",
              "nodejs",
              "interview",
              "questions"
          ]
      },
      {
          "title": "Node JS Interview Question — Set #04",
          "pubDate": "2018-09-13 15:45:53",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-04-b3ea7567675f?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/b3ea7567675f",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question — Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question — Set #03</a></li>\n</ul>\n<h3>Question 31</h3>\n<p>Have you used yarn as package manager and how its different from NPM</p>\n<p>Yarn is just another package manager for installing and managing javascript libraries for application. Yarn is using the same registry that npm does. That means that every package that is a available on npm is the same on Yarn.</p>\n<p>To add a package, run yarn add &lt;package-name&gt;.</p>\n<p>If you need a specific version of the package, you can use yarn add package@version</p>\n<p>yarn also have init command</p>\n<p>The yarn init command will walk you through the creation of a package.json file to configure some information about your package. This is same as we do npm init using npm package manager</p>\n<p>these are following differences we can see</p>\n<p>Yarn has a few differences from npm. Yarn is doing caching of all installed packages. Yarn is installing the packages simultaneously and when we install packages with Yarn it look like faster than NPM. Both yarn and NPM downloading packages from same NPM repository.</p>\n<p>On the contrary to npm, Yarn provides stability, putting lock on versions of installed packages. The speed is higher while installing packages. It is very important for big projects, which have more dependencies</p>\n<h3>Question 32</h3>\n<p>What are the tools to deploy node js application on server.</p>\n<p>There are many popular tool to deploy node js app on server which will keep node js application up and running and if there is any issue it will restart process like PM2, forever, supervisord</p>\n<p>PM2 provides :</p>\n<ol>\n<li>Built in load balancer</li>\n<li>Multiple instance of application running on same port.</li>\n<li>Can run application in cluster mode.</li>\n<li>Can manage deployment of multiple application using single config.</li>\n<li>Provides multiple deployment options.</li>\n<li>Provides zero downtime on application deployment.</li>\n</ol>\n<p>If you use pm2, you can easily hook it with keymetrics.io monitoring tool to see api statics.</p>\n<p>npm install -g pm2<br>pm2 start app.js</p>\n<p>Zero-config Load-Balancer Link</p>\n<p>PM2 enable use to create multiple instance to scale up your application by creating instances that share the same server port. Doing this also allow you to restart your app with zero-seconds downtimes.</p>\n<p>PM commands to start/stop/delete application instance</p>\n<p><strong>pm2 start</strong> app.js — name “my-api”</p>\n<p><strong>pm2 start</strong> web.js — name “web-interface”</p>\n<p><strong>pm2</strong> stop web-interface. …</p>\n<p><strong>pm2</strong> restart web-interface. …</p>\n<p><strong>pm2</strong> delete web-interface. …</p>\n<p><strong>pm2</strong> restart /http-[1,2]/ …</p>\n<p><strong>pm2</strong> list # Or <strong>pm2</strong> [list|ls|l|status]</p>\n<p>pm2 list command showing all available instances and pm2 monit command showing monitoring for all running instances</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pzO-erzJeIVNZLnO\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*R4av-BTK2E76Pb8Q\"></figure><p>PM2 has lot of advantages over other tools it gives you everything and its is industry standard for node js deployments.</p>\n<h3>Question 33</h3>\n<p>How to graceful shutdown your Node JS process when something bad happens in code like database connection lost.</p>\n<p>graceful shutdown means whenever node js process shut down in that case we need to shut process down gracefully by closing all db connection by releasing TCP port and releasing all occupied resources so when node process comes up again there should be no any issues</p>\n<p>graceful shot down can be done in different way</p>\n<p>Shutdown can happen using some code issue like unhandled promise rejection, some javascript code null check missing or database shutdown or forcefully by user using Ctrl + C</p>\n<pre>process.on(‘unhandledRejection’, ErrorHandler.unhandledRejection);<br>process.on(‘SIGINT’, ErrorHandler.shutdown);<br>process.on(‘uncaughtException’, ErrorHandler.onError);</pre>\n<pre>process<br> .on(‘unhandledRejection’, (reason, p) =&gt; {<br> console.error(reason, ‘Unhandled Rejection at Promise’, p);<br> // release database connection <br> // release resources<br> });</pre>\n<h3>Question 34</h3>\n<p><strong>How can you make sure of zero downtime while Node JS deployment of your application</strong></p>\n<p>zero downtime means whenever we deploy node js application it stop the application and then start it again in this case there is a downtime of some seconds until application gets connected to database like redis, mysql. Zero downtime can’t be achieved with single instance when we have huge traffic coming for APIs.</p>\n<p>PM2 is powerful tool to manage multiple instances running multiple core of one machine. On multi core system we should always have multiple instance of PM2 to optimally consume multiple cores of system.</p>\n<ol><li>For having zero downtime we should run application in cluster mode which allows networked Node.js applications (http(s)/tcp/udp server) to be scaled across all CPUs available, without any code modifications. This greatly increases the performance and reliability of your applications, depending on the number of CPUs available</li></ol>\n<p>To enable the cluster mode, just pass the -i option:</p>\n<p>pm2 start app.js -i max <strong>( max means that PM2 will auto detect the number of available CPUs and run as many processes as possible)</strong></p>\n<p>For zero downtime we should use pm2 reload not restart command, reload is different from restart as it will start reloading one by one and not doing reload on all instance together. <strong>pm2 restart app-name</strong> ,which kills and restarts the process. <strong>pm2 reload app-name</strong> which restart your workers one by one, and for each worker, wait till the new one has spawned before killing the old one. Using this reload we can serve request by live workers without having any issue in api-services.</p>\n<p>This below mentioned configuration “<strong>ecosystem.config.js</strong>” will create max number of instances based on available core on system and run all instances in cluster mode.</p>\n<p><strong>pm2</strong> <strong>startOrReload</strong> ecosystem.config.js <strong>— update-env</strong></p>\n<p>This command will start max number of instance if they have not been created yet or reload the existing created instances. — update-env parameter will reload instance with some newly added configuration.</p>\n<pre>Ecosystem.config.js file:</pre>\n<pre>module.exports = {<br> apps: [<br> {<br> name: ‘api_app’,<br> script: ‘app/server.js’,<br> instances: “max”<br> }<br> ]<br>};</pre>\n<h3>Question 35</h3>\n<p>What is the use of cluster module and how to use it.</p>\n<p>cluster module provide a way to create child process. In some cases we may need to have a child process for running some independent process and want to distribute some process. For that purpose we can use Cluster module which will create another child process and that process is created using like forking a process.</p>\n<p>The cluster module is core node js module like fs,net module. Cluster module contains a set of functions and properties that help us forking processes to take advantage of multi-core systems. Node js runs on single core system but when we have multi core system and in that case to use that multi core system we should create child process which are equal to number of processor in system</p>\n<pre><strong>const</strong> cluster = require(‘cluster’);<br><strong>const</strong> http = require(‘http’);<br><strong>const</strong> numCPUs = require(‘os’).cpus().length;<br><strong>if</strong> (cluster.isMaster) {<br> masterProcess();<br>} <strong>else</strong> {<br> childProcess(); <br>}<br><strong>function</strong> <strong>masterProcess</strong>() {<br> console.log(`Master ${process.pid} is running`);<br><strong>for</strong> (<strong>let</strong> i = 0; i &lt; numCPUs; i++) {<br> console.log(`Forking process number ${i}…`);<br> cluster.fork();<br> }<br> process.exit();<br>}</pre>\n<h3>Question 37</h3>\n<p>How can you debug you Node JSapplication.</p>\n<p>If you are using vscode like tool for writing node js apps then debugging is easier you can just run debugger in few simple steps.</p>\n<p>To start debugging, run your Node.js application with the — inspect flag.</p>\n<p>$ node — inspect &lt;your_file&gt;.js</p>\n<p>And you need to add chrome dev tools for that so you can launch debugger on chrome on some port and can do debugging like you do for client side javascript code.</p>\n<p>Another option is node-inspector</p>\n<p>$ npm install -g node-inspector</p>\n<p>$ node-debug app.js</p>\n<p>where app.js is the name of your main Node application JavaScript file.</p>\n<p>The node-debug command will load Node Inspector in your default browser.</p>\n<h3>Question 38</h3>\n<p><strong>what are streams and why we should use it with large data.</strong></p>\n<p>Streams are collections of items such as we have array as collection. The difference is that streams data might not be available all at same time and not necessary they all fit in existing memory. Stream data are not for synchronous execution. Stream are meant to be received over the time asynchronously.</p>\n<p>Stream are powerful tools to send response from apis when you have big data to send.</p>\n<p>This makes streams really powerful when working with large amounts of data, or data that’s coming from an external source one chunk at a time like file reading of big size. In that case we have to read file in chunks and need to stream that data to send in response.</p>\n<p>They also give us the power of sending data in chunks. Just like we use pipe command in linux and send data of one command to another command, we can do exactly the same in Node with streams.</p>\n<pre><strong>const</strong> fs = require(‘fs’);<br><strong>const</strong> server = require(‘http’).createServer();</pre>\n<pre>server.on(‘request’, (req, res) =&gt; {<br> fs.readFile(‘./app.txt’, (err, data) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br><br> res.end(data);<br> });<br>});</pre>\n<pre>// using streams //<br>server.on(‘request’, (req, res) =&gt; {<br><strong>const</strong> src = fs.createReadStream(‘./xpp.txt’);<br> src.pipe(res);<br>});Question 39</pre>\n<h3>Question 39</h3>\n<p>What are code module in Node JS explain few of them and their use.</p>\n<p>'Events',</p>\n<p>'fs',</p>\n<p>'http',</p>\n<p>'https',</p>\n<p>'module',</p>\n<p>'net',</p>\n<p>'os',</p>\n<p>'path',</p>\n<p>'stream'</p>\n<p><strong>child_process</strong></p>\n<p>The child_process module provides the ability to spawn child processes in a manner that is similar, but not</p>\n<p>identical, to popen(3).</p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<p><strong>cluster</strong></p>\n<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems the user will</p>\n<p>sometimes want to launch a cluster of Node.js processes to handle the load. The cluster module allows you to</p>\n<p>easily create child processes that all share server ports.</p>\n<p><a href=\"https://nodejs.org/api/cluster.html\">https://nodejs.org/api/cluster.html</a></p>\n<p><strong>Events</strong></p>\n<p>Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain</p>\n<p>kinds of objects (called “emitters”) periodically emit named events that cause Function objects (“listeners”) to be Called.</p>\n<p><a href=\"https://nodejs.org/api/events.html\">https://nodejs.org/api/events.html</a></p>\n<p><strong>fs</strong></p>\n<p>File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require(‘fs’). All the methods have asynchronous and synchronous forms.</p>\n<p><a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p><strong>http</strong></p>\n<p>The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages.</p>\n<p><strong>readline</strong></p>\n<p>The readline module provides an interface for reading data from a Readable stream (such as process.stdin) one line at a time.</p>\n<p><strong>repl</strong></p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications.</p>\n<p>Reference document</p>\n<p><a href=\"https://nodejs.org/en/docs/\">Docs | Node.js</a></p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<h3>Question 40</h3>\n<p>Explain event loop lifecycle and explain few events inside event loop.</p>\n<p>In latest release of V8 event loop is also available in JavaScript engine (v8, spiderMonkey etc). Event loop is part of Libuv library &amp; in reality event-loop is the master which uses the JavaScript engines to execute JavaScript code. event loop runs on separate thread.</p>\n<p>When you run node index.js in your console, node start the event-loop and then runs your main module main module from index.js outside the event loop. Once the main module is executed, node will check if the loop is alive if event loop is not alive then node js process simply exit otherwise it will keep listening the event queue</p>\n<p>At some point during the event loop, the runtime starts handling the messages on the queue, starting with the oldest one. Once that execution is over event is emitted about completion of task and handed over to handler.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*RvIia4KcBmfyhwmI\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b3ea7567675f\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question — Set #02</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402\">Node JS Interview Question — Set #03</a></li>\n</ul>\n<h3>Question 31</h3>\n<p>Have you used yarn as package manager and how its different from NPM</p>\n<p>Yarn is just another package manager for installing and managing javascript libraries for application. Yarn is using the same registry that npm does. That means that every package that is a available on npm is the same on Yarn.</p>\n<p>To add a package, run yarn add &lt;package-name&gt;.</p>\n<p>If you need a specific version of the package, you can use yarn add package@version</p>\n<p>yarn also have init command</p>\n<p>The yarn init command will walk you through the creation of a package.json file to configure some information about your package. This is same as we do npm init using npm package manager</p>\n<p>these are following differences we can see</p>\n<p>Yarn has a few differences from npm. Yarn is doing caching of all installed packages. Yarn is installing the packages simultaneously and when we install packages with Yarn it look like faster than NPM. Both yarn and NPM downloading packages from same NPM repository.</p>\n<p>On the contrary to npm, Yarn provides stability, putting lock on versions of installed packages. The speed is higher while installing packages. It is very important for big projects, which have more dependencies</p>\n<h3>Question 32</h3>\n<p>What are the tools to deploy node js application on server.</p>\n<p>There are many popular tool to deploy node js app on server which will keep node js application up and running and if there is any issue it will restart process like PM2, forever, supervisord</p>\n<p>PM2 provides :</p>\n<ol>\n<li>Built in load balancer</li>\n<li>Multiple instance of application running on same port.</li>\n<li>Can run application in cluster mode.</li>\n<li>Can manage deployment of multiple application using single config.</li>\n<li>Provides multiple deployment options.</li>\n<li>Provides zero downtime on application deployment.</li>\n</ol>\n<p>If you use pm2, you can easily hook it with keymetrics.io monitoring tool to see api statics.</p>\n<p>npm install -g pm2<br>pm2 start app.js</p>\n<p>Zero-config Load-Balancer Link</p>\n<p>PM2 enable use to create multiple instance to scale up your application by creating instances that share the same server port. Doing this also allow you to restart your app with zero-seconds downtimes.</p>\n<p>PM commands to start/stop/delete application instance</p>\n<p><strong>pm2 start</strong> app.js — name “my-api”</p>\n<p><strong>pm2 start</strong> web.js — name “web-interface”</p>\n<p><strong>pm2</strong> stop web-interface. …</p>\n<p><strong>pm2</strong> restart web-interface. …</p>\n<p><strong>pm2</strong> delete web-interface. …</p>\n<p><strong>pm2</strong> restart /http-[1,2]/ …</p>\n<p><strong>pm2</strong> list # Or <strong>pm2</strong> [list|ls|l|status]</p>\n<p>pm2 list command showing all available instances and pm2 monit command showing monitoring for all running instances</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*pzO-erzJeIVNZLnO\"></figure><figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*R4av-BTK2E76Pb8Q\"></figure><p>PM2 has lot of advantages over other tools it gives you everything and its is industry standard for node js deployments.</p>\n<h3>Question 33</h3>\n<p>How to graceful shutdown your Node JS process when something bad happens in code like database connection lost.</p>\n<p>graceful shutdown means whenever node js process shut down in that case we need to shut process down gracefully by closing all db connection by releasing TCP port and releasing all occupied resources so when node process comes up again there should be no any issues</p>\n<p>graceful shot down can be done in different way</p>\n<p>Shutdown can happen using some code issue like unhandled promise rejection, some javascript code null check missing or database shutdown or forcefully by user using Ctrl + C</p>\n<pre>process.on(‘unhandledRejection’, ErrorHandler.unhandledRejection);<br>process.on(‘SIGINT’, ErrorHandler.shutdown);<br>process.on(‘uncaughtException’, ErrorHandler.onError);</pre>\n<pre>process<br> .on(‘unhandledRejection’, (reason, p) =&gt; {<br> console.error(reason, ‘Unhandled Rejection at Promise’, p);<br> // release database connection <br> // release resources<br> });</pre>\n<h3>Question 34</h3>\n<p><strong>How can you make sure of zero downtime while Node JS deployment of your application</strong></p>\n<p>zero downtime means whenever we deploy node js application it stop the application and then start it again in this case there is a downtime of some seconds until application gets connected to database like redis, mysql. Zero downtime can’t be achieved with single instance when we have huge traffic coming for APIs.</p>\n<p>PM2 is powerful tool to manage multiple instances running multiple core of one machine. On multi core system we should always have multiple instance of PM2 to optimally consume multiple cores of system.</p>\n<ol><li>For having zero downtime we should run application in cluster mode which allows networked Node.js applications (http(s)/tcp/udp server) to be scaled across all CPUs available, without any code modifications. This greatly increases the performance and reliability of your applications, depending on the number of CPUs available</li></ol>\n<p>To enable the cluster mode, just pass the -i option:</p>\n<p>pm2 start app.js -i max <strong>( max means that PM2 will auto detect the number of available CPUs and run as many processes as possible)</strong></p>\n<p>For zero downtime we should use pm2 reload not restart command, reload is different from restart as it will start reloading one by one and not doing reload on all instance together. <strong>pm2 restart app-name</strong> ,which kills and restarts the process. <strong>pm2 reload app-name</strong> which restart your workers one by one, and for each worker, wait till the new one has spawned before killing the old one. Using this reload we can serve request by live workers without having any issue in api-services.</p>\n<p>This below mentioned configuration “<strong>ecosystem.config.js</strong>” will create max number of instances based on available core on system and run all instances in cluster mode.</p>\n<p><strong>pm2</strong> <strong>startOrReload</strong> ecosystem.config.js <strong>— update-env</strong></p>\n<p>This command will start max number of instance if they have not been created yet or reload the existing created instances. — update-env parameter will reload instance with some newly added configuration.</p>\n<pre>Ecosystem.config.js file:</pre>\n<pre>module.exports = {<br> apps: [<br> {<br> name: ‘api_app’,<br> script: ‘app/server.js’,<br> instances: “max”<br> }<br> ]<br>};</pre>\n<h3>Question 35</h3>\n<p>What is the use of cluster module and how to use it.</p>\n<p>cluster module provide a way to create child process. In some cases we may need to have a child process for running some independent process and want to distribute some process. For that purpose we can use Cluster module which will create another child process and that process is created using like forking a process.</p>\n<p>The cluster module is core node js module like fs,net module. Cluster module contains a set of functions and properties that help us forking processes to take advantage of multi-core systems. Node js runs on single core system but when we have multi core system and in that case to use that multi core system we should create child process which are equal to number of processor in system</p>\n<pre><strong>const</strong> cluster = require(‘cluster’);<br><strong>const</strong> http = require(‘http’);<br><strong>const</strong> numCPUs = require(‘os’).cpus().length;<br><strong>if</strong> (cluster.isMaster) {<br> masterProcess();<br>} <strong>else</strong> {<br> childProcess(); <br>}<br><strong>function</strong> <strong>masterProcess</strong>() {<br> console.log(`Master ${process.pid} is running`);<br><strong>for</strong> (<strong>let</strong> i = 0; i &lt; numCPUs; i++) {<br> console.log(`Forking process number ${i}…`);<br> cluster.fork();<br> }<br> process.exit();<br>}</pre>\n<h3>Question 37</h3>\n<p>How can you debug you Node JSapplication.</p>\n<p>If you are using vscode like tool for writing node js apps then debugging is easier you can just run debugger in few simple steps.</p>\n<p>To start debugging, run your Node.js application with the — inspect flag.</p>\n<p>$ node — inspect &lt;your_file&gt;.js</p>\n<p>And you need to add chrome dev tools for that so you can launch debugger on chrome on some port and can do debugging like you do for client side javascript code.</p>\n<p>Another option is node-inspector</p>\n<p>$ npm install -g node-inspector</p>\n<p>$ node-debug app.js</p>\n<p>where app.js is the name of your main Node application JavaScript file.</p>\n<p>The node-debug command will load Node Inspector in your default browser.</p>\n<h3>Question 38</h3>\n<p><strong>what are streams and why we should use it with large data.</strong></p>\n<p>Streams are collections of items such as we have array as collection. The difference is that streams data might not be available all at same time and not necessary they all fit in existing memory. Stream data are not for synchronous execution. Stream are meant to be received over the time asynchronously.</p>\n<p>Stream are powerful tools to send response from apis when you have big data to send.</p>\n<p>This makes streams really powerful when working with large amounts of data, or data that’s coming from an external source one chunk at a time like file reading of big size. In that case we have to read file in chunks and need to stream that data to send in response.</p>\n<p>They also give us the power of sending data in chunks. Just like we use pipe command in linux and send data of one command to another command, we can do exactly the same in Node with streams.</p>\n<pre><strong>const</strong> fs = require(‘fs’);<br><strong>const</strong> server = require(‘http’).createServer();</pre>\n<pre>server.on(‘request’, (req, res) =&gt; {<br> fs.readFile(‘./app.txt’, (err, data) =&gt; {<br><strong>if</strong> (err) <strong>throw</strong> err;<br><br> res.end(data);<br> });<br>});</pre>\n<pre>// using streams //<br>server.on(‘request’, (req, res) =&gt; {<br><strong>const</strong> src = fs.createReadStream(‘./xpp.txt’);<br> src.pipe(res);<br>});Question 39</pre>\n<h3>Question 39</h3>\n<p>What are code module in Node JS explain few of them and their use.</p>\n<p>'Events',</p>\n<p>'fs',</p>\n<p>'http',</p>\n<p>'https',</p>\n<p>'module',</p>\n<p>'net',</p>\n<p>'os',</p>\n<p>'path',</p>\n<p>'stream'</p>\n<p><strong>child_process</strong></p>\n<p>The child_process module provides the ability to spawn child processes in a manner that is similar, but not</p>\n<p>identical, to popen(3).</p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<p><strong>cluster</strong></p>\n<p>A single instance of Node.js runs in a single thread. To take advantage of multi-core systems the user will</p>\n<p>sometimes want to launch a cluster of Node.js processes to handle the load. The cluster module allows you to</p>\n<p>easily create child processes that all share server ports.</p>\n<p><a href=\"https://nodejs.org/api/cluster.html\">https://nodejs.org/api/cluster.html</a></p>\n<p><strong>Events</strong></p>\n<p>Much of the Node.js core API is built around an idiomatic asynchronous event-driven architecture in which certain</p>\n<p>kinds of objects (called “emitters”) periodically emit named events that cause Function objects (“listeners”) to be Called.</p>\n<p><a href=\"https://nodejs.org/api/events.html\">https://nodejs.org/api/events.html</a></p>\n<p><strong>fs</strong></p>\n<p>File I/O is provided by simple wrappers around standard POSIX functions. To use this module do require(‘fs’). All the methods have asynchronous and synchronous forms.</p>\n<p><a href=\"https://nodejs.org/api/fs.html\">https://nodejs.org/api/fs.html</a></p>\n<p><strong>http</strong></p>\n<p>The HTTP interfaces in Node.js are designed to support many features of the protocol which have been traditionally difficult to use. In particular, large, possibly chunk-encoded, messages.</p>\n<p><strong>readline</strong></p>\n<p>The readline module provides an interface for reading data from a Readable stream (such as process.stdin) one line at a time.</p>\n<p><strong>repl</strong></p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications.</p>\n<p>Reference document</p>\n<p><a href=\"https://nodejs.org/en/docs/\">Docs | Node.js</a></p>\n<p><a href=\"https://nodejs.org/api/child_process.html\">https://nodejs.org/api/child_process.html</a></p>\n<h3>Question 40</h3>\n<p>Explain event loop lifecycle and explain few events inside event loop.</p>\n<p>In latest release of V8 event loop is also available in JavaScript engine (v8, spiderMonkey etc). Event loop is part of Libuv library &amp; in reality event-loop is the master which uses the JavaScript engines to execute JavaScript code. event loop runs on separate thread.</p>\n<p>When you run node index.js in your console, node start the event-loop and then runs your main module main module from index.js outside the event loop. Once the main module is executed, node will check if the loop is alive if event loop is not alive then node js process simply exit otherwise it will keep listening the event queue</p>\n<p>At some point during the event loop, the runtime starts handling the messages on the queue, starting with the oldest one. Once that execution is over event is emitted about completion of task and handed over to handler.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*RvIia4KcBmfyhwmI\"></figure><img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b3ea7567675f\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "interview",
              "questions",
              "javascript",
              "nodejs"
          ]
      },
      {
          "title": "Node JS Interview Question — Set #03",
          "pubDate": "2018-09-13 15:37:03",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-03-b0b5af44b402?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/b0b5af44b402",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question — Set #02</a></li>\n</ul>\n<h3>Question 21</h3>\n<p>What is callback hell and how can it be avoided any library which can be used and how to promisify the library</p>\n<p>Callback hell refers to a coding style which we use like when we add nested callbacks in application, Lot of nesting of callback functions create callback hell. The code it becomes difficult to debug and understand in such cases we can use other library to overcome with callback hell problem</p>\n<blockquote>a. Using promises<br>b. Yield operator and Generator functions from ES6<br>c. Modularising code<br>d. Using async library using async waterfall<br>e. by not doing nested callback</blockquote>\n<p>In javascript most of library supports callback way of writing code like redis-client, mysql-client all such library are callback based so better if we promisify these library and use them with promises</p>\n<a href=\"https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href\">https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href</a><p>We can use util core module to promisify module in node js like we can promisify fs module which provide callback based operation fileread.</p>\n<a href=\"https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href\">https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href</a><p>Now callback based file read write operation become promise based and we need to do “.then()” to capture response from resolved promise.</p>\n<h3>Question 22</h3>\n<p>What are promises and how to use promises for simple AJAX call or for multiple AJAX calls</p>\n<p>Promises give an alternate way to write asynchronous code and it gives advantages over callback.</p>\n<p>We can use promises instead of using callbacks. Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejected <strong>.then</strong> method gets triggered Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<pre>readFileAsync(filePath, {encoding: ‘utf8’})<br> .then((text) =&gt; {<br> console.log(‘CONTENT:’, text);<br> })<br> .catch((err) =&gt; {<br> console.log(‘ERROR:’, err);<br> });<br><strong>function</strong> <strong>readFileAsync</strong>(){<br><strong>return</strong> <strong>new</strong> Promises(<strong>function</strong>(resolve,reject){<br> resolve(‘some data’)<br> })<br>}</pre>\n<h3>Question 23</h3>\n<p>What is global object in Node JS &amp; how it can used to manage environments in application.</p>\n<p>The Global keyword represents the global namespace object, we can get what is in global by opening node terminal or you can do console.log(global) in your application</p>\n<p>when we declare variable using let/const those are module specific modules but when we declare without using let/var they gets added to global namespace of application.</p>\n<p>We can also add few things on global object like runtime environment configuration</p>\n<p>Process, buffer is also part of Global object</p>\n<p>Process in very big object having all information about process here we also have global.process.env where we can manage environment specific configuration</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*KY0SPQbYlOW3TfM4\"></figure><p>In our application we pass these env variable while running node application like</p>\n<blockquote>Node index.js node_env=local port=5009</blockquote>\n<p>In this example we will get local when we try to get value of process.env.node_env and will get 5009 when we do process.env.port in our code.</p>\n<h3>Question 24</h3>\n<p>What are streams and how it’s different from normal api response</p>\n<p>Streams are just flow of data, steam pipes that let you easily read data from a source and pipe it to a destination. so stream are easy to pipe from one source to another, A stream is nothing but an EventEmitter and implements some specials methods. Depending on the applied methods in node js code , a stream becomes Readable, Writable, or Duplex (both readable and writable).</p>\n<p>There are different use cases of streams we can use stream to pipe response to api server.</p>\n<p>For example we can create file reader stream which read file until data in completed from that file and during that we have some events also like read start or data event or error events</p>\n<pre><strong>var</strong> fs = require(“fs”);<br><strong>var</strong> data = ‘’;<br><strong>var</strong> readerStream = fs.createReadStream(‘input.txt’);<br>readerStream.setEncoding(‘UTF8’);<br>readerStream.on(‘data’, <strong>function</strong>(chunk) {<br> data += chunk;<br>});<br>readerStream.on(‘end’,<strong>function</strong>(){<br> console.log(data);<br>});<br>readerStream.on(‘error’, <strong>function</strong>(err){<br> console.log(err.stack);<br>});</pre>\n<h3>Question 25</h3>\n<p>How we can have separate config for development &amp; production</p>\n<p>environments, configuration file like which manages database connection</p>\n<p>There are different option either you can use .dotenv module to manage configuration for application runtime.</p>\n<p>We can manage different config file based on different environments like dev.properties qa.properties file</p>\n<p>At runtime we should pass process.env.NODE_DNV as either development or production so in code we can load appropriate env file and further we can load its configurations like mongodb url, Mysql connection url which will be different for development and production</p>\n<p>we can require that file and can get configuration object and pass them wherever required.</p>\n<pre><strong>var</strong> config = {<br> production: {<br> mongo : {<br> url: ‘****’<br> }<br> },<br> dev: {<br> mongo : {<br> url: ‘****’<br> }<br> }<br>}<br>exports.get = <strong>function</strong> <strong>get</strong>(env) {<br><strong>return</strong> config[env] || config.default;<br>}<br><strong>const</strong> config = require(‘./config/config.js’).get(process.env.NODE_ENV);<br><strong>const</strong> dbconn = mongoose.createConnection(config.mongo.url);</pre>\n<h3>Question 26</h3>\n<p>What are the modules type which node js currently supporting.</p>\n<p>In Javascript we have modules like es6, commonjs, AMD,UMD.</p>\n<p>The obvious one for Node JS is CommonJS, which is the current module system used by Node JS (the one that uses require and module.exports). CommonJS already is a module system for NodeJS, and ES Modules has to learn to live side by side and interoperate with it</p>\n<p>whatever we do today using module.export &amp; require all are common js modules available on npm repository</p>\n<p>All module downloaded from npmjs.com or npm repository supports common js style of require and exports</p>\n<p>Till now if we want to use ES6 modules in ES6 like using import and export syntax we have to use babel polyfill like babel-register or babel-node as there is no native support for ES6 modules in node js</p>\n<p>Node js native doesn’t support ES6 modules or code like import/export</p>\n<p><strong>But now native support is coming but with slight change, these will be called ESM module with extension of .esm</strong></p>\n<pre><strong>export const spout = ‘the spout’<br>export const handle = ‘the handle’<br>export const tea = ‘hot tea’</strong></pre>\n<pre><strong>import {handle, spout, tea} from ‘./01-kettle.mjs’</strong></pre>\n<pre><strong>console.log(handle) // ==&gt; the handle<br>console.log(spout) // ==&gt; the spout<br>console.log(tea) // ==&gt; hot tea</strong></pre>\n<h3>Question 27</h3>\n<p><strong>what is the differences between promises, callback &amp; async await</strong></p>\n<p>Async await has been introduced recently and powerful tool to write asynchronous code in synchronous fashion, async await code look like simple synchronous code and it blocks the event loop and implemented on top of promises only.</p>\n<p>Async functions</p>\n<p>For async we just need to add it before function name as “async” function</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>return</strong> 1;<br>}</pre>\n<p>Async before a function always returns a promise. If the code has return &lt;non-promise&gt; in it, then JavaScript automatically wraps it into a resolved promise with that value.</p>\n<p>let value = await promise;</p>\n<p>The keyword await makes JavaScript wait until that promise settles and returns its result.</p>\n<p>Here’s example with a promise that resolves in 1 second:</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>let</strong> promise = <strong>new</strong> Promise((resolve, reject) =&gt; {<br> setTimeout(() =&gt; resolve(“done!”), 1000)<br> });<br><strong>let</strong> result = <strong>await</strong> promise; // wait till the promise resolves (*)<br> alert(result); // “done!”<br>}<br>f();</pre>\n<p>Promises are another important tool in javascript to manage asynchronous code.</p>\n<p>Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejected <strong>.then</strong> method gets triggered, Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<p>Promises allow us to cleanly chain chain subsequent operations while avoiding callback hell and as long as you always return a promise for each of your then blocks, it will continue down the chain.</p>\n<a href=\"https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href\">https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href</a><p>Promises are now supported in native code so no need to add external library. Promises are just representation of asynchronous code which can be in resolved/rejected state and accordingly .then function will execute with proper callback</p>\n<p>Little bit about callback</p>\n<p>Node handles all asynchronous operation using callback natively. Callbacks are just functions that you pass to other functions. Example like while reading file using fs core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callback function</p>\n<h3>Question 28</h3>\n<p><strong>What is event loop, is it part of V8 runtime environment and also available on browser.</strong></p>\n<p>The event loop is provided by the libuv library. It is not part of V8 runtime env.</p>\n<p>it is single thread entity keeps running in node js process and keep listening the event queue.</p>\n<p>The Event Loop is the entity that handles external events and converts them into callback invocations. It is a loop that picks events from the event queues and pushes their callbacks into the Call Stack.</p>\n<p>There is only one thread that executes JavaScript code and this is the thread where the event loop is running. The execution of callbacks is done by the event loop.</p>\n<p>To understand more on event loop you can use this reference link</p>\n<p><a href=\"https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c\">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jhSp7O52Z6XpZopT\"></figure><h3>Question 29</h3>\n<p>what will be the state of Node JS process when event loop is empty and call stack both are empty.</p>\n<p>In such case node js process will exit as it has nothing to process nothing to execute, it is different from any other process, when we start node js process it will start event loop and if there is nothing to execute in event loop it will exit from there</p>\n<p>To prevent this situation we always create http server where server keeps telling event loop for listening http request events and event loop is not totally idle.</p>\n<pre><strong>var</strong> http=require(‘http’)<br><strong>var</strong> server=http.createServer(serverFn)<br>server.listen(7000);</pre>\n<h3>Question 30</h3>\n<p><strong>What is call stack, is it part of V8 runtime environment ?</strong></p>\n<p><strong>Yes call stack is a part of Javascript having either chrome V8 engine or chakra engine.</strong></p>\n<p><strong>The JavaScript engine V8 is a single threaded interpreter having a heap and a single call stack.</strong> The browser additionally provides some APIs like the DOM, AJAX, and Timers. This is main core functionality which is responsible to execute functions using heap and call stack (Stack which use LIFO pattern)</p>\n<p>Call stack operates by principle of Last In, First Out known as LIFO, it says that the last function that gets pushed into the stack is the first to be pop out, when the function returns.It pure stack like data structure based operation.</p>\n<p>We can see that in below example where function calling each other.</p>\n<p>1. When secondFn() gets executed, an empty stack frame is created. It is the main entry point of the program.</p>\n<p>2. secondFn() then calls firstFn() which is pushed into the stack using LIFO pattern.</p>\n<p>3. firstFn() returns and prints “Hello from firstFn” to the console.</p>\n<p>4. firstFn() is pop off the stack.</p>\n<p>5. The execution order then move to secondFunction().</p>\n<p>6. secondFn() returns and print “The end from secondFunction” to the console.</p>\n<p>7. secondFn() is pop off the stack, clearing the memory occupied.</p>\n<pre><strong>function</strong> <strong>firstFn</strong>(){<br><strong>console.log</strong>(‘hello from first Fn’);<br>}<br><strong>function</strong> <strong>secondFn</strong>(){<br> firstFn();<br>}<br><strong>function</strong> <strong>thirdFn</strong>(){<br> secondFn();<br>}<br>thirdFn();</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b0b5af44b402\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*wsNJ7KtXPU4p9X-m\"></figure><ul>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></li>\n<li><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98\">Node JS Interview Question — Set #02</a></li>\n</ul>\n<h3>Question 21</h3>\n<p>What is callback hell and how can it be avoided any library which can be used and how to promisify the library</p>\n<p>Callback hell refers to a coding style which we use like when we add nested callbacks in application, Lot of nesting of callback functions create callback hell. The code it becomes difficult to debug and understand in such cases we can use other library to overcome with callback hell problem</p>\n<blockquote>a. Using promises<br>b. Yield operator and Generator functions from ES6<br>c. Modularising code<br>d. Using async library using async waterfall<br>e. by not doing nested callback</blockquote>\n<p>In javascript most of library supports callback way of writing code like redis-client, mysql-client all such library are callback based so better if we promisify these library and use them with promises</p>\n<a href=\"https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href\">https://medium.com/media/85acf9af5fcc28feadd238b6b39cf841/href</a><p>We can use util core module to promisify module in node js like we can promisify fs module which provide callback based operation fileread.</p>\n<a href=\"https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href\">https://medium.com/media/67010aa295efe48919ef0750c03cdee1/href</a><p>Now callback based file read write operation become promise based and we need to do “.then()” to capture response from resolved promise.</p>\n<h3>Question 22</h3>\n<p>What are promises and how to use promises for simple AJAX call or for multiple AJAX calls</p>\n<p>Promises give an alternate way to write asynchronous code and it gives advantages over callback.</p>\n<p>We can use promises instead of using callbacks. Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejected <strong>.then</strong> method gets triggered Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<pre>readFileAsync(filePath, {encoding: ‘utf8’})<br> .then((text) =&gt; {<br> console.log(‘CONTENT:’, text);<br> })<br> .catch((err) =&gt; {<br> console.log(‘ERROR:’, err);<br> });<br><strong>function</strong> <strong>readFileAsync</strong>(){<br><strong>return</strong> <strong>new</strong> Promises(<strong>function</strong>(resolve,reject){<br> resolve(‘some data’)<br> })<br>}</pre>\n<h3>Question 23</h3>\n<p>What is global object in Node JS &amp; how it can used to manage environments in application.</p>\n<p>The Global keyword represents the global namespace object, we can get what is in global by opening node terminal or you can do console.log(global) in your application</p>\n<p>when we declare variable using let/const those are module specific modules but when we declare without using let/var they gets added to global namespace of application.</p>\n<p>We can also add few things on global object like runtime environment configuration</p>\n<p>Process, buffer is also part of Global object</p>\n<p>Process in very big object having all information about process here we also have global.process.env where we can manage environment specific configuration</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*KY0SPQbYlOW3TfM4\"></figure><p>In our application we pass these env variable while running node application like</p>\n<blockquote>Node index.js node_env=local port=5009</blockquote>\n<p>In this example we will get local when we try to get value of process.env.node_env and will get 5009 when we do process.env.port in our code.</p>\n<h3>Question 24</h3>\n<p>What are streams and how it’s different from normal api response</p>\n<p>Streams are just flow of data, steam pipes that let you easily read data from a source and pipe it to a destination. so stream are easy to pipe from one source to another, A stream is nothing but an EventEmitter and implements some specials methods. Depending on the applied methods in node js code , a stream becomes Readable, Writable, or Duplex (both readable and writable).</p>\n<p>There are different use cases of streams we can use stream to pipe response to api server.</p>\n<p>For example we can create file reader stream which read file until data in completed from that file and during that we have some events also like read start or data event or error events</p>\n<pre><strong>var</strong> fs = require(“fs”);<br><strong>var</strong> data = ‘’;<br><strong>var</strong> readerStream = fs.createReadStream(‘input.txt’);<br>readerStream.setEncoding(‘UTF8’);<br>readerStream.on(‘data’, <strong>function</strong>(chunk) {<br> data += chunk;<br>});<br>readerStream.on(‘end’,<strong>function</strong>(){<br> console.log(data);<br>});<br>readerStream.on(‘error’, <strong>function</strong>(err){<br> console.log(err.stack);<br>});</pre>\n<h3>Question 25</h3>\n<p>How we can have separate config for development &amp; production</p>\n<p>environments, configuration file like which manages database connection</p>\n<p>There are different option either you can use .dotenv module to manage configuration for application runtime.</p>\n<p>We can manage different config file based on different environments like dev.properties qa.properties file</p>\n<p>At runtime we should pass process.env.NODE_DNV as either development or production so in code we can load appropriate env file and further we can load its configurations like mongodb url, Mysql connection url which will be different for development and production</p>\n<p>we can require that file and can get configuration object and pass them wherever required.</p>\n<pre><strong>var</strong> config = {<br> production: {<br> mongo : {<br> url: ‘****’<br> }<br> },<br> dev: {<br> mongo : {<br> url: ‘****’<br> }<br> }<br>}<br>exports.get = <strong>function</strong> <strong>get</strong>(env) {<br><strong>return</strong> config[env] || config.default;<br>}<br><strong>const</strong> config = require(‘./config/config.js’).get(process.env.NODE_ENV);<br><strong>const</strong> dbconn = mongoose.createConnection(config.mongo.url);</pre>\n<h3>Question 26</h3>\n<p>What are the modules type which node js currently supporting.</p>\n<p>In Javascript we have modules like es6, commonjs, AMD,UMD.</p>\n<p>The obvious one for Node JS is CommonJS, which is the current module system used by Node JS (the one that uses require and module.exports). CommonJS already is a module system for NodeJS, and ES Modules has to learn to live side by side and interoperate with it</p>\n<p>whatever we do today using module.export &amp; require all are common js modules available on npm repository</p>\n<p>All module downloaded from npmjs.com or npm repository supports common js style of require and exports</p>\n<p>Till now if we want to use ES6 modules in ES6 like using import and export syntax we have to use babel polyfill like babel-register or babel-node as there is no native support for ES6 modules in node js</p>\n<p>Node js native doesn’t support ES6 modules or code like import/export</p>\n<p><strong>But now native support is coming but with slight change, these will be called ESM module with extension of .esm</strong></p>\n<pre><strong>export const spout = ‘the spout’<br>export const handle = ‘the handle’<br>export const tea = ‘hot tea’</strong></pre>\n<pre><strong>import {handle, spout, tea} from ‘./01-kettle.mjs’</strong></pre>\n<pre><strong>console.log(handle) // ==&gt; the handle<br>console.log(spout) // ==&gt; the spout<br>console.log(tea) // ==&gt; hot tea</strong></pre>\n<h3>Question 27</h3>\n<p><strong>what is the differences between promises, callback &amp; async await</strong></p>\n<p>Async await has been introduced recently and powerful tool to write asynchronous code in synchronous fashion, async await code look like simple synchronous code and it blocks the event loop and implemented on top of promises only.</p>\n<p>Async functions</p>\n<p>For async we just need to add it before function name as “async” function</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>return</strong> 1;<br>}</pre>\n<p>Async before a function always returns a promise. If the code has return &lt;non-promise&gt; in it, then JavaScript automatically wraps it into a resolved promise with that value.</p>\n<p>let value = await promise;</p>\n<p>The keyword await makes JavaScript wait until that promise settles and returns its result.</p>\n<p>Here’s example with a promise that resolves in 1 second:</p>\n<pre><strong>async</strong> <strong>function</strong> <strong>f</strong>() {<br><strong>let</strong> promise = <strong>new</strong> Promise((resolve, reject) =&gt; {<br> setTimeout(() =&gt; resolve(“done!”), 1000)<br> });<br><strong>let</strong> result = <strong>await</strong> promise; // wait till the promise resolves (*)<br> alert(result); // “done!”<br>}<br>f();</pre>\n<p>Promises are another important tool in javascript to manage asynchronous code.</p>\n<p>Promises either return the result of execution or the error/exception. Promises have different state resolved, rejected or pending state. Once promise resolved or rejected <strong>.then</strong> method gets triggered, Promises simply requires the use of &lt;.then()&gt; function which waits for the promise object to return and once you have final state it gets executed. Promise.then() function takes two arguments, both are callback functions first for success callback and another error callbacks.</p>\n<p>Promises allow us to cleanly chain chain subsequent operations while avoiding callback hell and as long as you always return a promise for each of your then blocks, it will continue down the chain.</p>\n<a href=\"https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href\">https://medium.com/media/c7a3eb8032f2ec9f684f76f0527b96c3/href</a><p>Promises are now supported in native code so no need to add external library. Promises are just representation of asynchronous code which can be in resolved/rejected state and accordingly .then function will execute with proper callback</p>\n<p>Little bit about callback</p>\n<p>Node handles all asynchronous operation using callback natively. Callbacks are just functions that you pass to other functions. Example like while reading file using fs core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callback function</p>\n<h3>Question 28</h3>\n<p><strong>What is event loop, is it part of V8 runtime environment and also available on browser.</strong></p>\n<p>The event loop is provided by the libuv library. It is not part of V8 runtime env.</p>\n<p>it is single thread entity keeps running in node js process and keep listening the event queue.</p>\n<p>The Event Loop is the entity that handles external events and converts them into callback invocations. It is a loop that picks events from the event queues and pushes their callbacks into the Call Stack.</p>\n<p>There is only one thread that executes JavaScript code and this is the thread where the event loop is running. The execution of callbacks is done by the event loop.</p>\n<p>To understand more on event loop you can use this reference link</p>\n<p><a href=\"https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c\">https://medium.com/the-node-js-collection/what-you-should-know-to-really-understand-the-node-js-event-loop-and-its-metrics-c4907b19da4c</a></p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*jhSp7O52Z6XpZopT\"></figure><h3>Question 29</h3>\n<p>what will be the state of Node JS process when event loop is empty and call stack both are empty.</p>\n<p>In such case node js process will exit as it has nothing to process nothing to execute, it is different from any other process, when we start node js process it will start event loop and if there is nothing to execute in event loop it will exit from there</p>\n<p>To prevent this situation we always create http server where server keeps telling event loop for listening http request events and event loop is not totally idle.</p>\n<pre><strong>var</strong> http=require(‘http’)<br><strong>var</strong> server=http.createServer(serverFn)<br>server.listen(7000);</pre>\n<h3>Question 30</h3>\n<p><strong>What is call stack, is it part of V8 runtime environment ?</strong></p>\n<p><strong>Yes call stack is a part of Javascript having either chrome V8 engine or chakra engine.</strong></p>\n<p><strong>The JavaScript engine V8 is a single threaded interpreter having a heap and a single call stack.</strong> The browser additionally provides some APIs like the DOM, AJAX, and Timers. This is main core functionality which is responsible to execute functions using heap and call stack (Stack which use LIFO pattern)</p>\n<p>Call stack operates by principle of Last In, First Out known as LIFO, it says that the last function that gets pushed into the stack is the first to be pop out, when the function returns.It pure stack like data structure based operation.</p>\n<p>We can see that in below example where function calling each other.</p>\n<p>1. When secondFn() gets executed, an empty stack frame is created. It is the main entry point of the program.</p>\n<p>2. secondFn() then calls firstFn() which is pushed into the stack using LIFO pattern.</p>\n<p>3. firstFn() returns and prints “Hello from firstFn” to the console.</p>\n<p>4. firstFn() is pop off the stack.</p>\n<p>5. The execution order then move to secondFunction().</p>\n<p>6. secondFn() returns and print “The end from secondFunction” to the console.</p>\n<p>7. secondFn() is pop off the stack, clearing the memory occupied.</p>\n<pre><strong>function</strong> <strong>firstFn</strong>(){<br><strong>console.log</strong>(‘hello from first Fn’);<br>}<br><strong>function</strong> <strong>secondFn</strong>(){<br> firstFn();<br>}<br><strong>function</strong> <strong>thirdFn</strong>(){<br> secondFn();<br>}<br>thirdFn();</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b0b5af44b402\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript"
          ]
      },
      {
          "title": "Node JS Interview Question — Set #02",
          "pubDate": "2018-09-13 15:25:43",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-02-b2798d76cd98?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/b2798d76cd98",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*iSwccAU7q1qFmMxw",
          "description": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*iSwccAU7q1qFmMxw\"></figure><p><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></p>\n<h3>Question 11</h3>\n<p>how single threaded Node JS handles concurrency when multiple I/O operations happening</p>\n<p>Node provides a single thread to the code we are writing so that code can be written easily and without bottleneck and without I/O blocking Node internally uses multiple POSIX/unix threads for various I/O operations such as network read, database read or file read operations.</p>\n<p>When Node apis or code get I/O request it creates a thread from thread pool to perform that asynchronous operation and once the operation is done, it pushes the result to the event queue. On each such event, event loop runs and checks the queue and if the execution stack of Node is empty then it adds the queue result to execution stack.</p>\n<p>This is how Node manages concurrency.</p>\n<p>Reference : <a href=\"https://strongloop.com/strongblog/node-js-is-faster-than-java/\">https://strongloop.com/strongblog/node-js-is-faster-than-java/</a></p>\n<p>Request modeling is different, In node js its not creating separate thread for every request, just running event loop and delegating to async thread for running async tasks.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*fr65aKR3wSjSnulo\"></figure><h3>Question 12</h3>\n<p>What is Node JS callback and how it helps to run Async tasks</p>\n<p>Callback is a Node.js function which can be created with plain javascript code. While writing callback you don’t need node js environment. It’s just higher order function which takes function as argument and return callback function . This function is used to avoid I/O or network blocking and allows next instruction to run</p>\n<p>Node JS handle all asynchronous calls via callback natively. Callbacks are just functions that you pass to other functions. which we call as higher order function in javascript. Example on callback is while reading file using fs node js core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callback function</p>\n<p>Node.js use callback function extensively. Node APIs are written to support callbacks of Node JS.</p>\n<pre><strong>var</strong> fs = require(“fs”);<br> fs.readFile(‘app.txt’, <strong>function</strong> (err, data) {<br><strong>if</strong> (err) <strong>return</strong> console.error(err);<br> console.log(data.toString());<br> });<br> console.log(“Program Ended”);</pre>\n<h3>Question 13</h3>\n<p>Explain basic async apis in javascript like setTimeout, setImmediate &amp; setInterval</p>\n<p>The setTimeout &amp; setInterval are the 2 timers functions.these function are being used to create timer function.</p>\n<p><strong>setTimeout</strong> :- This function is used to delay the execution of code written under it. This will execute once after the defined delay in milliseconds.</p>\n<p><strong>After 1 second we will get console message saying “Hello”</strong></p>\n<pre><strong>function</strong> <strong>sayHi</strong>() {<br> console.log(‘Hello’);<br>}<br>setTimeout(sayHi, 1000);</pre>\n<pre><strong>setInterval </strong>:-<strong> </strong>if you want to execute a function many times or unlimited times then we can use .<strong>setInterval</strong>() by passing the interval duration.</pre>\n<p>This function will keep executing after every second and print value of i on console</p>\n<pre>let i = 0;<br>function increment() {<br>i++;<br><em>console</em>.log(i);<br>}<br>var myVar = setInterval(increment, 1000);<br>// clearInterval(myVar);</pre>\n<p>clearInterval method will be used to clearout the execution of method from setInterval</p>\n<p><strong>setImmediate</strong>() and setTimeout() are based on the event loop.</p>\n<p>Another important method in setImmediate, we use setImmediate if we want to queue the function behind whatever I/O event callbacks that are already in the event queue.</p>\n<p>we can use process.nextTick to effectively queue the function at the head of the event queue so that it executes immediately after the current function completes. It queues them immediately after the last I/O handler somewhat like process.nextTick. So it is faster.</p>\n<h3>Question 14</h3>\n<p>What is REPL in Node JSand how it helps to run code.</p>\n<p>Node.js comes with environment called REPL (aka Node shell). REPL stands for Read-Eval-Print-Loop, its easiest way to run node js code on console.</p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications. It can be accessed using:</p>\n<p>will give you a result which is similar to the one you will get in the console of Google Chrome browser, it look like chrome console without browser based apis</p>\n<p><strong>const</strong> repl = require(‘repl’);</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*7l-UKBgt62cia0fG\"></figure><h3>Question 15</h3>\n<p>What are core and important modules in node JS which used frequently and explain difference between core module and user defined module</p>\n<p>Node.js being lightweight framework. All the core modules include minimum functionalities of Node.js. These core modules are compiled into its binary distribution and load automatically when Node.js process starts</p>\n<blockquote>\n<strong>Cluster </strong>The cluster module helps us to create children process that runs simultaneously and share the same server port. So using this we can create process running on same port, As node js is single threaded and efficiently use memory by consuming single core only but when we are running on multi core system in such case to take advantage of multi-core systems Cluster module allows you to easily create child processes that each runs on their own single thread, to handle the load.</blockquote>\n<p>Crypto — To handle OpenSSL cryptographic functions<br>Dgram — Provides implementation of UDP datagram sockets<br>Dns — To do DNS lookups and name resolution functions<br>Domain — Deprecated. To handle unhandled errors<br>Events — To handle events<br>Fs — To handle the file system<br>Http — To make Node.js act as an HTTP server<br>Https — To make Node.js act as an HTTPS server.<br>Net — To create servers and clients<br>Os — Provides information about the operation system<br>Path — To handle file paths</p>\n<p>All above mentioned are code module in node js as they are coming bundled with node js installation. User defined module are those which we are creating in node js application and writing module.export in file and again making them require in another file.</p>\n<p>Reference : <a href=\"https://nodejs.org/api/synopsis.html\">https://nodejs.org/api/synopsis.html</a></p>\n<h3>Question 16</h3>\n<p>Explain events in Node JS and how events are helping us to create event driven system.</p>\n<p>every action has reaction similarly every event has it handler to catch the action and take action on it.</p>\n<p>In node js we have event emitter which is used to emit event and further that event can be captured to perform some operation.</p>\n<p>Events can be compared by simple socker.io example when server broadcast a message it can be captured by all client who are subscribing to that channel.</p>\n<p>Node.js has a built-in core module known as “Events”, where you can create, fire, and listen for your own events.</p>\n<p>Its plain and simple we create events and written handler at another place to capture that event</p>\n<p>To include the built-in Events module use the require() method. All event properties and methods are an instance of EventEmitter object available on events so to be able to access these properties and methods we need to create an EventEmitter object:</p>\n<pre><strong>var</strong> events = require(‘events’);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<p>Here is the example where we are emitting event name “scream” and there is a handler my eventHandler which is capturing this event and processing task. These events are like fire and forget you fire and forget them.</p>\n<pre><strong>var</strong> events = require(‘events’);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<pre>//Create an event handler:<br><strong>var</strong> myEventHandler = <strong>function</strong> () {<br> console.log(‘I hear a scream!’);<br>}</pre>\n<pre>//Assign the event handler to an event:<br>eventEmitter.on(‘scream’, myEventHandler);</pre>\n<pre>//Fire the ‘scream’ event:<br>eventEmitter.emit(‘scream’);</pre>\n<h3>Question 17</h3>\n<p>How we can read file in synchronous way &amp; asynchronous way using fs module.</p>\n<p>The normal behaviour in Node.js is to read in the content of a file in a non-blocking,asynchronous way. That is to tell Node to read the file and return callback once you are done with reading file, there are different events also like file read started or file read over.</p>\n<p>We use core module fs and fs.readfile provides asynchronous way of reading file</p>\n<p>For this we can use the readFile method of the fs core module</p>\n<p>Node js core module fs takes 3 arguments, These arguments are name of the file (‘app.txt’ in this case), the encoding of the file (‘utf8’), and a callback function as argument. This function which is a callback function going to be called when the file-reading operation has finished and we will see file content printed on terminal.</p>\n<p>As this operation is non I/O blocking and asynchronous in nature, this will be process using event loop but execution will not be blocked we will see message “file read is over” before getting file contents on terminal</p>\n<pre><strong>var</strong> fs = require(‘fs’);<br>fs.readFile(app.txt, ‘utf8’, <strong>function</strong>(err, contents) {<br> console.log(contents);<br>});<br>console.log(‘file read is Over’);</pre>\n<p>There is another way to use blocking file read operation using fs.readFileSync which will read file in synchronous way and it block the execution until unless file read operation is over.</p>\n<pre><strong>var</strong> fs = require(‘fs’);<br><strong>var</strong> contents = fs.readFileSync(‘app.txt’, ‘utf8’);<br>console.log(contents);</pre>\n<pre>console.log(‘file read is Over’);</pre>\n<h3>Question 18</h3>\n<p>How to capture command line arguments while executing node js process.</p>\n<p>The arguments are stored in process.argv when you pass args with node command</p>\n<p>like node index.js “hello” “world”</p>\n<p>[runtime] [script_name] [argument-1 argument-2 argument-3 … argument-n]</p>\n<p>process.argv is an array containing the command line arguments. The first element will be ‘node’, the second element will be the name of the JavaScript file. The next elements will be any additional command line arguments.</p>\n<p>we can get all arguments printed using this Loop</p>\n<p>and we can pass information to an application before it starts. This is particularly useful if you want to perform some settings before starting application like passing env and port</p>\n<pre>process.argv.forEach(<strong>function</strong> (val, index, array) {<br> console.log(index + ‘: ‘ + val);<br>});</pre>\n<h3>Question 19</h3>\n<p>What is error check first in callback handler defined in Node JS code.</p>\n<p>generally, the first argument to any callback handler is an an error object and there is a reason to pass first argument as error object in callback handler which can be either null or error object so while dealing with callback we can check if we have received null or some error object</p>\n<p>if we get error object then we will perform our action based on error. Error handling by a typical callback handler could be as follows:</p>\n<pre><strong>function</strong> <strong>callback</strong>(err, results) {<br> // usually we’ll check for the error before handling results<br><strong>if</strong>(err) {<br> // handle error somehow and return<br> }<br> // no error, perform standard callback handling<br>}</pre>\n<p>This is applied to all callbacks we write in our code and its part of ESLint configuration which force developer to write code in this way.</p>\n<h3>Question 20</h3>\n<p>What are different module pattern in javascript, can you explain common JS modules.</p>\n<p>In JavaScript, the word “modules” refers to small units of independent, reusable code. They are the foundation of many JavaScript design patterns and are critically necessary when building any non-trivial JavaScript-based application.</p>\n<p>We have different module pattern in javascript like commonjs, AMD, UMD and ES6 modules</p>\n<p>A CommonJS module is essentially a reusable piece of code can be fetched from either nomjs.com repository or created locally. From module we can exports specific objects, making them available for other modules to require in their programs. While writing node js code you have seen this and may be very familiar with this format.</p>\n<p>Using Common JS every JavaScript file stores modules in its own unique module context (just like wrapping it in a closure).We use module.export to export module and require to require that module in another file.</p>\n<p>module.export and require syntax we use everywhere in Node js Code, all common js modules are imported in such a way only</p>\n<pre><strong>var</strong> app = require(‘./app’)<br><strong>function</strong> <strong>myModule</strong>() {<br><strong>this</strong>.hello = <strong>function</strong>() {<br><strong>return</strong> ‘hello!’;<br> }<br><strong>this</strong>.goodbye = <strong>function</strong>() {<br><strong>return</strong> ‘goodbye!’;<br> }<br>}<br>module.exports = myModule;</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b2798d76cd98\" width=\"1\" height=\"1\">\n",
          "content": "\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*iSwccAU7q1qFmMxw\"></figure><p><a href=\"https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3\">Node JS Interview Question — Set #01</a></p>\n<h3>Question 11</h3>\n<p>how single threaded Node JS handles concurrency when multiple I/O operations happening</p>\n<p>Node provides a single thread to the code we are writing so that code can be written easily and without bottleneck and without I/O blocking Node internally uses multiple POSIX/unix threads for various I/O operations such as network read, database read or file read operations.</p>\n<p>When Node apis or code get I/O request it creates a thread from thread pool to perform that asynchronous operation and once the operation is done, it pushes the result to the event queue. On each such event, event loop runs and checks the queue and if the execution stack of Node is empty then it adds the queue result to execution stack.</p>\n<p>This is how Node manages concurrency.</p>\n<p>Reference : <a href=\"https://strongloop.com/strongblog/node-js-is-faster-than-java/\">https://strongloop.com/strongblog/node-js-is-faster-than-java/</a></p>\n<p>Request modeling is different, In node js its not creating separate thread for every request, just running event loop and delegating to async thread for running async tasks.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*fr65aKR3wSjSnulo\"></figure><h3>Question 12</h3>\n<p>What is Node JS callback and how it helps to run Async tasks</p>\n<p>Callback is a Node.js function which can be created with plain javascript code. While writing callback you don’t need node js environment. It’s just higher order function which takes function as argument and return callback function . This function is used to avoid I/O or network blocking and allows next instruction to run</p>\n<p>Node JS handle all asynchronous calls via callback natively. Callbacks are just functions that you pass to other functions. which we call as higher order function in javascript. Example on callback is while reading file using fs node js core module we pass first argument is the path of the file and second argument is a function, which is nothing but a callback function</p>\n<p>Node.js use callback function extensively. Node APIs are written to support callbacks of Node JS.</p>\n<pre><strong>var</strong> fs = require(“fs”);<br> fs.readFile(‘app.txt’, <strong>function</strong> (err, data) {<br><strong>if</strong> (err) <strong>return</strong> console.error(err);<br> console.log(data.toString());<br> });<br> console.log(“Program Ended”);</pre>\n<h3>Question 13</h3>\n<p>Explain basic async apis in javascript like setTimeout, setImmediate &amp; setInterval</p>\n<p>The setTimeout &amp; setInterval are the 2 timers functions.these function are being used to create timer function.</p>\n<p><strong>setTimeout</strong> :- This function is used to delay the execution of code written under it. This will execute once after the defined delay in milliseconds.</p>\n<p><strong>After 1 second we will get console message saying “Hello”</strong></p>\n<pre><strong>function</strong> <strong>sayHi</strong>() {<br> console.log(‘Hello’);<br>}<br>setTimeout(sayHi, 1000);</pre>\n<pre><strong>setInterval </strong>:-<strong> </strong>if you want to execute a function many times or unlimited times then we can use .<strong>setInterval</strong>() by passing the interval duration.</pre>\n<p>This function will keep executing after every second and print value of i on console</p>\n<pre>let i = 0;<br>function increment() {<br>i++;<br><em>console</em>.log(i);<br>}<br>var myVar = setInterval(increment, 1000);<br>// clearInterval(myVar);</pre>\n<p>clearInterval method will be used to clearout the execution of method from setInterval</p>\n<p><strong>setImmediate</strong>() and setTimeout() are based on the event loop.</p>\n<p>Another important method in setImmediate, we use setImmediate if we want to queue the function behind whatever I/O event callbacks that are already in the event queue.</p>\n<p>we can use process.nextTick to effectively queue the function at the head of the event queue so that it executes immediately after the current function completes. It queues them immediately after the last I/O handler somewhat like process.nextTick. So it is faster.</p>\n<h3>Question 14</h3>\n<p>What is REPL in Node JSand how it helps to run code.</p>\n<p>Node.js comes with environment called REPL (aka Node shell). REPL stands for Read-Eval-Print-Loop, its easiest way to run node js code on console.</p>\n<p>The repl module provides a Read-Eval-Print-Loop (REPL) implementation that is available both as a standalone program or includible in other applications. It can be accessed using:</p>\n<p>will give you a result which is similar to the one you will get in the console of Google Chrome browser, it look like chrome console without browser based apis</p>\n<p><strong>const</strong> repl = require(‘repl’);</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*7l-UKBgt62cia0fG\"></figure><h3>Question 15</h3>\n<p>What are core and important modules in node JS which used frequently and explain difference between core module and user defined module</p>\n<p>Node.js being lightweight framework. All the core modules include minimum functionalities of Node.js. These core modules are compiled into its binary distribution and load automatically when Node.js process starts</p>\n<blockquote>\n<strong>Cluster </strong>The cluster module helps us to create children process that runs simultaneously and share the same server port. So using this we can create process running on same port, As node js is single threaded and efficiently use memory by consuming single core only but when we are running on multi core system in such case to take advantage of multi-core systems Cluster module allows you to easily create child processes that each runs on their own single thread, to handle the load.</blockquote>\n<p>Crypto — To handle OpenSSL cryptographic functions<br>Dgram — Provides implementation of UDP datagram sockets<br>Dns — To do DNS lookups and name resolution functions<br>Domain — Deprecated. To handle unhandled errors<br>Events — To handle events<br>Fs — To handle the file system<br>Http — To make Node.js act as an HTTP server<br>Https — To make Node.js act as an HTTPS server.<br>Net — To create servers and clients<br>Os — Provides information about the operation system<br>Path — To handle file paths</p>\n<p>All above mentioned are code module in node js as they are coming bundled with node js installation. User defined module are those which we are creating in node js application and writing module.export in file and again making them require in another file.</p>\n<p>Reference : <a href=\"https://nodejs.org/api/synopsis.html\">https://nodejs.org/api/synopsis.html</a></p>\n<h3>Question 16</h3>\n<p>Explain events in Node JS and how events are helping us to create event driven system.</p>\n<p>every action has reaction similarly every event has it handler to catch the action and take action on it.</p>\n<p>In node js we have event emitter which is used to emit event and further that event can be captured to perform some operation.</p>\n<p>Events can be compared by simple socker.io example when server broadcast a message it can be captured by all client who are subscribing to that channel.</p>\n<p>Node.js has a built-in core module known as “Events”, where you can create, fire, and listen for your own events.</p>\n<p>Its plain and simple we create events and written handler at another place to capture that event</p>\n<p>To include the built-in Events module use the require() method. All event properties and methods are an instance of EventEmitter object available on events so to be able to access these properties and methods we need to create an EventEmitter object:</p>\n<pre><strong>var</strong> events = require(‘events’);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<p>Here is the example where we are emitting event name “scream” and there is a handler my eventHandler which is capturing this event and processing task. These events are like fire and forget you fire and forget them.</p>\n<pre><strong>var</strong> events = require(‘events’);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();</pre>\n<pre>//Create an event handler:<br><strong>var</strong> myEventHandler = <strong>function</strong> () {<br> console.log(‘I hear a scream!’);<br>}</pre>\n<pre>//Assign the event handler to an event:<br>eventEmitter.on(‘scream’, myEventHandler);</pre>\n<pre>//Fire the ‘scream’ event:<br>eventEmitter.emit(‘scream’);</pre>\n<h3>Question 17</h3>\n<p>How we can read file in synchronous way &amp; asynchronous way using fs module.</p>\n<p>The normal behaviour in Node.js is to read in the content of a file in a non-blocking,asynchronous way. That is to tell Node to read the file and return callback once you are done with reading file, there are different events also like file read started or file read over.</p>\n<p>We use core module fs and fs.readfile provides asynchronous way of reading file</p>\n<p>For this we can use the readFile method of the fs core module</p>\n<p>Node js core module fs takes 3 arguments, These arguments are name of the file (‘app.txt’ in this case), the encoding of the file (‘utf8’), and a callback function as argument. This function which is a callback function going to be called when the file-reading operation has finished and we will see file content printed on terminal.</p>\n<p>As this operation is non I/O blocking and asynchronous in nature, this will be process using event loop but execution will not be blocked we will see message “file read is over” before getting file contents on terminal</p>\n<pre><strong>var</strong> fs = require(‘fs’);<br>fs.readFile(app.txt, ‘utf8’, <strong>function</strong>(err, contents) {<br> console.log(contents);<br>});<br>console.log(‘file read is Over’);</pre>\n<p>There is another way to use blocking file read operation using fs.readFileSync which will read file in synchronous way and it block the execution until unless file read operation is over.</p>\n<pre><strong>var</strong> fs = require(‘fs’);<br><strong>var</strong> contents = fs.readFileSync(‘app.txt’, ‘utf8’);<br>console.log(contents);</pre>\n<pre>console.log(‘file read is Over’);</pre>\n<h3>Question 18</h3>\n<p>How to capture command line arguments while executing node js process.</p>\n<p>The arguments are stored in process.argv when you pass args with node command</p>\n<p>like node index.js “hello” “world”</p>\n<p>[runtime] [script_name] [argument-1 argument-2 argument-3 … argument-n]</p>\n<p>process.argv is an array containing the command line arguments. The first element will be ‘node’, the second element will be the name of the JavaScript file. The next elements will be any additional command line arguments.</p>\n<p>we can get all arguments printed using this Loop</p>\n<p>and we can pass information to an application before it starts. This is particularly useful if you want to perform some settings before starting application like passing env and port</p>\n<pre>process.argv.forEach(<strong>function</strong> (val, index, array) {<br> console.log(index + ‘: ‘ + val);<br>});</pre>\n<h3>Question 19</h3>\n<p>What is error check first in callback handler defined in Node JS code.</p>\n<p>generally, the first argument to any callback handler is an an error object and there is a reason to pass first argument as error object in callback handler which can be either null or error object so while dealing with callback we can check if we have received null or some error object</p>\n<p>if we get error object then we will perform our action based on error. Error handling by a typical callback handler could be as follows:</p>\n<pre><strong>function</strong> <strong>callback</strong>(err, results) {<br> // usually we’ll check for the error before handling results<br><strong>if</strong>(err) {<br> // handle error somehow and return<br> }<br> // no error, perform standard callback handling<br>}</pre>\n<p>This is applied to all callbacks we write in our code and its part of ESLint configuration which force developer to write code in this way.</p>\n<h3>Question 20</h3>\n<p>What are different module pattern in javascript, can you explain common JS modules.</p>\n<p>In JavaScript, the word “modules” refers to small units of independent, reusable code. They are the foundation of many JavaScript design patterns and are critically necessary when building any non-trivial JavaScript-based application.</p>\n<p>We have different module pattern in javascript like commonjs, AMD, UMD and ES6 modules</p>\n<p>A CommonJS module is essentially a reusable piece of code can be fetched from either nomjs.com repository or created locally. From module we can exports specific objects, making them available for other modules to require in their programs. While writing node js code you have seen this and may be very familiar with this format.</p>\n<p>Using Common JS every JavaScript file stores modules in its own unique module context (just like wrapping it in a closure).We use module.export to export module and require to require that module in another file.</p>\n<p>module.export and require syntax we use everywhere in Node js Code, all common js modules are imported in such a way only</p>\n<pre><strong>var</strong> app = require(‘./app’)<br><strong>function</strong> <strong>myModule</strong>() {<br><strong>this</strong>.hello = <strong>function</strong>() {<br><strong>return</strong> ‘hello!’;<br> }<br><strong>this</strong>.goodbye = <strong>function</strong>() {<br><strong>return</strong> ‘goodbye!’;<br> }<br>}<br>module.exports = myModule;</pre>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=b2798d76cd98\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "javascript"
          ]
      },
      {
          "title": "Node JS Interview Question — Set #01",
          "pubDate": "2018-09-13 15:11:51",
          "link": "https://medium.com/@tkssharma/node-js-interview-question-set-01-73c2b87c6ae3?source=rss-9bea52c4baff------2",
          "guid": "https://medium.com/p/73c2b87c6ae3",
          "author": "Tarun Sharma",
          "thumbnail": "https://cdn-images-1.medium.com/max/700/0*37d-Wo6TFWi6oaXR",
          "description": "\n<h3>50 Essential Node-JS Interview Questions-Part-#1</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*37d-Wo6TFWi6oaXR\"></figure><h3>Question 1</h3>\n<p>What is NPM &amp; how its being used with Node JS</p>\n<p>npm is the package manager for JavaScript based application and the world’s largest software registry having thousands of javascript modules.You can Discover packages of reusable code — and assemble them in powerful new ways.</p>\n<p>NPM is powerful package manager to install new package for your application. It will give you common js modules.</p>\n<p>NPM gives you capability to initialize application using package.json.</p>\n<p>NPM and yarn are most popular package manager to manage javascript modules.If you are creating some reusable code and wanted to share with others you can create NPM module and push in to NPM and that module can be used by others.</p>\n<pre>npm init</pre>\n<pre>npm install -save react</pre>\n<pre>npm instal -g webpack</pre>\n<pre>npm instal — save-dev gulp</pre>\n<p>We can install package globally, Locally and install package in dev dependencies.</p>\n<p>Global packages will be available system wide and can be accessed on system cli like webpack and webpack-dev-server modules.</p>\n<p>npm as package manager install new package for application which can be added globally locally in your application as local module or local dependencies.</p>\n<p>Node js is using NPM and its coming with node version as default package manager to manage dependencies locally and globally.</p>\n<h3>Question 2</h3>\n<p>What is Node.JS? When should we use Node JS</p>\n<p>Node.js is a server side language based on Google’s V8 JavaScript engine.</p>\n<p>It is used to build scalable programs and need to run very fast. Its built on top of V8 runtime engine whose baseline in libio &amp; libuv Libraries for c ++.</p>\n<p>Node js can be used to build api and application required real time interface like reading live data, streaming data and doing socket communication.</p>\n<p>Node js should never be used with CPU intensive tasks like reading huge files and reading lot of data from database and sending it somewhere else.</p>\n<p>Node.js is a highly efficient which can scale enough &amp; provide non-blocking I/O running on single thread event loop that was built on top of Google Chrome V8 engine and its ECMAScript.</p>\n<ul>\n<li>Node JS provide scalable applications</li>\n<li>Node JS is server side javascript and single threaded.</li>\n<li>Node JS adds non I/O blocking platform.</li>\n<li>Node JS is built on top of v8 chrome engine.</li>\n<li>Node JS provides faster way to create REST APIs and have good stack of library to support applications.</li>\n<li>Node JS providing faster application development and can be used in microservices like environments.</li>\n</ul>\n<h3>Question 3</h3>\n<p>What is of Node js platform stack, what are different libraries it is using.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/256/0*8D6zO4umZz-oBEPT\"></figure><p>Node JS using V8 runtime Engine same as chrome is using, it built on top of same chrome engine.</p>\n<p>It’s an open source JIT(Just In Time) compiler written in c++ which has outperformed PHP, Ruby and python performance wise. V8 compiler compiles Javascript directly into assembly level code. V8 Runtime environment comprises into 3 major component</p>\n<p>Compiler : dissects the JS code</p>\n<p>Optimizer : Optimizer called crankshaft create abstract syntax tree(AST) which further converts to SSA : static single assignment and gets optimized</p>\n<p>Garbage Collector : it removes dead objects from new space and puts into old space. Garbage collector play vital role in keeping Node Js lightweight.</p>\n<p>Base library are c++ library and libeio managing thread pool so javascript engine here is single thread but internally its managing thread pool.</p>\n<p>2. Libuv/libio : A C++ library</p>\n<p>This library handles Node’s asynchronous I/O operation and main event loop. There are thread pool reserve in Libuv which handles the thread allocation to individual I/O operations.</p>\n<p>On top of c++ library node js has binding with http, socket io binding which are being invoked by core modules of node js like fs, net, dns, socket.io, http.</p>\n<p>Node js standard library are written in javascript to access c++ library interface and access interface as Node js will be running on server not on simple browser accessing html and javascript.</p>\n<h3>Question 4</h3>\n<p>What is Node JS Architecture.</p>\n<p>Node is single threaded and based on non I/O blocking way of dealing with operation.</p>\n<p>It is fast and scalable while running on single thread and doing I/O operation like database read, file read in asynchronous way using event loop.</p>\n<p>Node JS is single threaded or its javascript interface is single threaded, but this is a half truth, actually it is event-driven and single-threaded with background workers. The Event loop is single-threaded but most of the I/O works run on separate threads, because the I/O APIs in Node.js are asynchronous/non-blocking by design, in order to accommodate the event loop.</p>\n<p>Node js event loop is feature of Node js base library, Node js is running on single threaded environment and can provide more performance using this single threaded event driven model, Node js manages event loop keeps running in search of asynchronous request.</p>\n<p>Node js event loop keeps running and whenever any asynchronous request comes its places in event loop if event loop is not busy and gets processed and further notified once execution over, Once you are getting multiple async requests then it pushed all request to event queue and start processing request one by one without blocking the code execution.</p>\n<p>Event loop is a part of Libeio library and running as single thread keeps waiting for async request ina cycle once it sees anything coming it will process it.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*VOFPFmZjhWpUXXhH\"></figure><h3>Question 5</h3>\n<p>Explain in depth about event loop mechanism in Node JS.</p>\n<p>The Event Loop is a queue of callback functions. When an async function executes like setTimeout, the callback function is pushed to the queue. The JavaScript engine doesn’t continue processing the event loop until the code after an async function has executed.</p>\n<p>Event-loop is the main part of the node js system. it keeps running and executing as long as node js process are active in memory. It’s responsible for handling asynchronous operations in application like http call, I/O operation and database read. These all request will be queued to the event loop waiting to be executed on the next free I/O, on execution completion the event loop will got notified to trigger a callback to the main function.</p>\n<pre>request(‘http://www.google.com', function(error, response, body) {</pre>\n<pre>console.log(body);</pre>\n<pre>});<br>console.log(‘Done!’);</pre>\n<p>In above code example, using request module we are making an http call on google.com url. It is asynchronous operation as you will reading data from network. This task will be pushed to event queue if event loop is busy in processing tasks &amp; further once event loop if free, event queue will send that I/O request to event loop for execution. we will get response from the callback added in this code, it will get executed once we have response from I/O task.</p>\n<p>Node js runtime execution is not blocked by asynchronous tasks, it will move to the next statement like in above example after running http call using request module it will move to console.log statement. we will see output on console and after sometime we will be notified with this callback with data coming from network request.</p>\n<h3>Question 6</h3>\n<ol><li>What is the role of package.json and what are NPM scripts</li></ol>\n<p>This file package.json has the information about the project. this gives information to npm that allows it to identify the project as well as handle the project’s dependencies either local or devdependencies.</p>\n<p>Some of the fields are basic information like name, name, description, author and dependencies, script and some meta tags.</p>\n<p>if you install application using npm then all the dependencies listed will be installed as well. Additionally, after installation it create./node_modules directory.</p>\n<p>Package.json is just json file having meta information about application. Here main part is npm scripts which are important part and will be executing our application with different commands. Like running node js process either we write node index.js on terminal directly or we just run npm run start.</p>\n<p>Which one is better</p>\n<p>We use npm scripts to automate our tasks and list all them together in npm scripts where we can execute them using npm run &lt;task-name&gt;, npm scripts are powerful you can add pre and post hooks for these tasks. These will work like task runners we used to have like gulp and grunt.</p>\n<pre>{<br> “name”: “node-js-sample”,<br> “version”: “0.2.0”,<br> “description”: “A sample Node.js app using Express 4”,<br> “main”: “index.js”,<br> “scripts”: {<br> “start”: “node index.js”<br> },<br> “dependencies”: {<br> “express”: “⁴.13.3”<br> },<br> “engines”: {<br> “node”: “4.0.0”<br> },<br> “repository”: {<br> “type”: “git”,<br> “url”: “https://github.com/heroku/node-js-sample\"<br> },<br> “keywords”: [<br> “node”,<br> “heroku”,<br> “express”<br> ],<br> “author”: “Mark Pundsack”,<br> “contributors”: [<br> “Zeke Sikelianos &lt;zeke@sikelianos.com&gt; (http://zeke.sikelianos.com)\"<br> ],<br> “license”: “MIT”<br>}</pre>\n<p>In this above mentioned package.json we have script tag and having start task, so npm scripts enable execution of this tasks using</p>\n<p>npm run start will run node index.js</p>\n<h3>Question 7</h3>\n<p>What is Event-driven programming? And how Node JS is event driven language</p>\n<p>From the name itself its clean that what is event driven something driven by some event so in node js we can write events can trigger something once those event occurs</p>\n<p>Event driven programming : Node js is having event loop on single thread and there is always one event will be running and always there will be one handle to handle that event without interruption.</p>\n<p>Before getting into code of eventEmitter we should understand why event loop is best example of event driven programming.</p>\n<p>Event loop perform two operation in a loop</p>\n<pre><strong>var</strong> events = require(‘events’);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();<br>//Create an event handler:<br><strong>var</strong> EventHandler = <strong>function</strong> () {<br> console.log(‘I hear a voice!’);<br>}<br>//Assign the event handler to an event:<br>eventEmitter.on(‘’horror’’, EventHandler);<br>//Fire the ‘scream’ event:<br>eventEmitter.emit(‘horror’)</pre>\n<ol>\n<li>Event detection</li>\n<li>Event handler triggering</li>\n</ol>\n<p>There can be different events like on database read do that or on doing this successfully after that run this code.</p>\n<p>Those things can be done using events, event is a core modules where we can emit event from one place and can define handler which can take care of handling that event.</p>\n<p>Example below showing events by extending <strong>EventEmitter</strong> class, its code sample using classes where we have created custom event emitter by extending EventEmitter class and emitting event and capturing it.</p>\n<pre><strong>const</strong> EventEmitter = require(‘events’);<br><strong>class</strong> <strong>MyEmitter</strong> <strong>extends</strong> <strong>EventEmitter</strong> {}<br><strong>const</strong> CustomEmitter = <strong>new</strong> MyEmitter();<br>CustomEmitter.on(‘event’, <strong>function</strong>(a, b) {<br> console.log(‘processed in first iteration’,a,b);<br>});<br>CustomEmitter.emit(‘event’, ‘Hi’, ‘Hello’);</pre>\n<h3>Question 8</h3>\n<p>How Node JS V8 runtime is different from what we have on chrome console</p>\n<p>Chrome console and Node js both are using V8 javascript runtime engine but major difference is Node JS using other c++ core libraries to manage http and socket communication and Chrome V8 engine is mainly browser oriented environments where node js is browserless environment mainly CLI based to execute tasks.</p>\n<p>On browser we have access to window, document and console objects and in Node js we don’t have document &amp; window objects available, it is server side runtime environment which can be executed from command line. Node js mainly used for creating HTTP server, socket communication or reading or writing real time data.</p>\n<h3>Question 9</h3>\n<p>What is the difference between Asynchronous function, Synchronous function or pure functions</p>\n<p><strong>Synchronous function</strong> : Those function which do simple execution and don’t deal with I/O, These are simple function where we can predict output also and have only basic operation having data manipulation</p>\n<p><strong>Asynchronous Function</strong> : Special function which deals with network I/O operations like database read, file read or getting data from some api. These operation always takes time while executing and you do not receive instant response from these api.</p>\n<p>simple example asynchronous code sample :</p>\n<pre><strong>var</strong> userDetails;<br><strong>function</strong> <strong>initialize</strong>() {<br> // Setting URL and headers for request<br><strong>var</strong> options = {<br> url: ‘https://api.github.com/users/narenaryan'<br> };<br><strong>return</strong> <strong>new</strong> Promise(<strong>function</strong>(resolve, reject) {<br> // Do async job<br> request.get(options, <strong>function</strong>(err, resp, body) {<br><strong>if</strong> (err) {<br> reject(err);<br> } <strong>else</strong> {<br> resolve(JSON.parse(body));<br> }<br> })<br> })<br>}</pre>\n<pre><strong>// Synchronous code sample</strong></pre>\n<pre><strong>function</strong> <strong>foo</strong>(){}<br><strong>function</strong> <strong>bar</strong>(){<br> foo();<br>}<br><strong>function</strong> <strong>baz</strong>(){<br> bar();<br>}<br>baz();</pre>\n<h3>Question 10</h3>\n<p>what are different options to write asynchronous code in Node.</p>\n<blockquote>\n<strong>Using setTimeout</strong> we can run some code after defined time</blockquote>\n<blockquote>\n<strong>Using callback</strong> : return function from another function after asynchronous task is over.</blockquote>\n<blockquote>\n<strong>Using Async module </strong>: async module in node js</blockquote>\n<blockquote>\n<strong>Using promises</strong> : using native promises and wait until promise is resolved</blockquote>\n<blockquote>Using some library like b<strong>luebird,Q library</strong>.</blockquote>\n<blockquote>\n<strong>Using async/await</strong> : write less line of code by using async await</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=73c2b87c6ae3\" width=\"1\" height=\"1\">\n",
          "content": "\n<h3>50 Essential Node-JS Interview Questions-Part-#1</h3>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/700/0*37d-Wo6TFWi6oaXR\"></figure><h3>Question 1</h3>\n<p>What is NPM &amp; how its being used with Node JS</p>\n<p>npm is the package manager for JavaScript based application and the world’s largest software registry having thousands of javascript modules.You can Discover packages of reusable code — and assemble them in powerful new ways.</p>\n<p>NPM is powerful package manager to install new package for your application. It will give you common js modules.</p>\n<p>NPM gives you capability to initialize application using package.json.</p>\n<p>NPM and yarn are most popular package manager to manage javascript modules.If you are creating some reusable code and wanted to share with others you can create NPM module and push in to NPM and that module can be used by others.</p>\n<pre>npm init</pre>\n<pre>npm install -save react</pre>\n<pre>npm instal -g webpack</pre>\n<pre>npm instal — save-dev gulp</pre>\n<p>We can install package globally, Locally and install package in dev dependencies.</p>\n<p>Global packages will be available system wide and can be accessed on system cli like webpack and webpack-dev-server modules.</p>\n<p>npm as package manager install new package for application which can be added globally locally in your application as local module or local dependencies.</p>\n<p>Node js is using NPM and its coming with node version as default package manager to manage dependencies locally and globally.</p>\n<h3>Question 2</h3>\n<p>What is Node.JS? When should we use Node JS</p>\n<p>Node.js is a server side language based on Google’s V8 JavaScript engine.</p>\n<p>It is used to build scalable programs and need to run very fast. Its built on top of V8 runtime engine whose baseline in libio &amp; libuv Libraries for c ++.</p>\n<p>Node js can be used to build api and application required real time interface like reading live data, streaming data and doing socket communication.</p>\n<p>Node js should never be used with CPU intensive tasks like reading huge files and reading lot of data from database and sending it somewhere else.</p>\n<p>Node.js is a highly efficient which can scale enough &amp; provide non-blocking I/O running on single thread event loop that was built on top of Google Chrome V8 engine and its ECMAScript.</p>\n<ul>\n<li>Node JS provide scalable applications</li>\n<li>Node JS is server side javascript and single threaded.</li>\n<li>Node JS adds non I/O blocking platform.</li>\n<li>Node JS is built on top of v8 chrome engine.</li>\n<li>Node JS provides faster way to create REST APIs and have good stack of library to support applications.</li>\n<li>Node JS providing faster application development and can be used in microservices like environments.</li>\n</ul>\n<h3>Question 3</h3>\n<p>What is of Node js platform stack, what are different libraries it is using.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/256/0*8D6zO4umZz-oBEPT\"></figure><p>Node JS using V8 runtime Engine same as chrome is using, it built on top of same chrome engine.</p>\n<p>It’s an open source JIT(Just In Time) compiler written in c++ which has outperformed PHP, Ruby and python performance wise. V8 compiler compiles Javascript directly into assembly level code. V8 Runtime environment comprises into 3 major component</p>\n<p>Compiler : dissects the JS code</p>\n<p>Optimizer : Optimizer called crankshaft create abstract syntax tree(AST) which further converts to SSA : static single assignment and gets optimized</p>\n<p>Garbage Collector : it removes dead objects from new space and puts into old space. Garbage collector play vital role in keeping Node Js lightweight.</p>\n<p>Base library are c++ library and libeio managing thread pool so javascript engine here is single thread but internally its managing thread pool.</p>\n<p>2. Libuv/libio : A C++ library</p>\n<p>This library handles Node’s asynchronous I/O operation and main event loop. There are thread pool reserve in Libuv which handles the thread allocation to individual I/O operations.</p>\n<p>On top of c++ library node js has binding with http, socket io binding which are being invoked by core modules of node js like fs, net, dns, socket.io, http.</p>\n<p>Node js standard library are written in javascript to access c++ library interface and access interface as Node js will be running on server not on simple browser accessing html and javascript.</p>\n<h3>Question 4</h3>\n<p>What is Node JS Architecture.</p>\n<p>Node is single threaded and based on non I/O blocking way of dealing with operation.</p>\n<p>It is fast and scalable while running on single thread and doing I/O operation like database read, file read in asynchronous way using event loop.</p>\n<p>Node JS is single threaded or its javascript interface is single threaded, but this is a half truth, actually it is event-driven and single-threaded with background workers. The Event loop is single-threaded but most of the I/O works run on separate threads, because the I/O APIs in Node.js are asynchronous/non-blocking by design, in order to accommodate the event loop.</p>\n<p>Node js event loop is feature of Node js base library, Node js is running on single threaded environment and can provide more performance using this single threaded event driven model, Node js manages event loop keeps running in search of asynchronous request.</p>\n<p>Node js event loop keeps running and whenever any asynchronous request comes its places in event loop if event loop is not busy and gets processed and further notified once execution over, Once you are getting multiple async requests then it pushed all request to event queue and start processing request one by one without blocking the code execution.</p>\n<p>Event loop is a part of Libeio library and running as single thread keeps waiting for async request ina cycle once it sees anything coming it will process it.</p>\n<figure><img alt=\"\" src=\"https://cdn-images-1.medium.com/max/1024/0*VOFPFmZjhWpUXXhH\"></figure><h3>Question 5</h3>\n<p>Explain in depth about event loop mechanism in Node JS.</p>\n<p>The Event Loop is a queue of callback functions. When an async function executes like setTimeout, the callback function is pushed to the queue. The JavaScript engine doesn’t continue processing the event loop until the code after an async function has executed.</p>\n<p>Event-loop is the main part of the node js system. it keeps running and executing as long as node js process are active in memory. It’s responsible for handling asynchronous operations in application like http call, I/O operation and database read. These all request will be queued to the event loop waiting to be executed on the next free I/O, on execution completion the event loop will got notified to trigger a callback to the main function.</p>\n<pre>request(‘http://www.google.com', function(error, response, body) {</pre>\n<pre>console.log(body);</pre>\n<pre>});<br>console.log(‘Done!’);</pre>\n<p>In above code example, using request module we are making an http call on google.com url. It is asynchronous operation as you will reading data from network. This task will be pushed to event queue if event loop is busy in processing tasks &amp; further once event loop if free, event queue will send that I/O request to event loop for execution. we will get response from the callback added in this code, it will get executed once we have response from I/O task.</p>\n<p>Node js runtime execution is not blocked by asynchronous tasks, it will move to the next statement like in above example after running http call using request module it will move to console.log statement. we will see output on console and after sometime we will be notified with this callback with data coming from network request.</p>\n<h3>Question 6</h3>\n<ol><li>What is the role of package.json and what are NPM scripts</li></ol>\n<p>This file package.json has the information about the project. this gives information to npm that allows it to identify the project as well as handle the project’s dependencies either local or devdependencies.</p>\n<p>Some of the fields are basic information like name, name, description, author and dependencies, script and some meta tags.</p>\n<p>if you install application using npm then all the dependencies listed will be installed as well. Additionally, after installation it create./node_modules directory.</p>\n<p>Package.json is just json file having meta information about application. Here main part is npm scripts which are important part and will be executing our application with different commands. Like running node js process either we write node index.js on terminal directly or we just run npm run start.</p>\n<p>Which one is better</p>\n<p>We use npm scripts to automate our tasks and list all them together in npm scripts where we can execute them using npm run &lt;task-name&gt;, npm scripts are powerful you can add pre and post hooks for these tasks. These will work like task runners we used to have like gulp and grunt.</p>\n<pre>{<br> “name”: “node-js-sample”,<br> “version”: “0.2.0”,<br> “description”: “A sample Node.js app using Express 4”,<br> “main”: “index.js”,<br> “scripts”: {<br> “start”: “node index.js”<br> },<br> “dependencies”: {<br> “express”: “⁴.13.3”<br> },<br> “engines”: {<br> “node”: “4.0.0”<br> },<br> “repository”: {<br> “type”: “git”,<br> “url”: “https://github.com/heroku/node-js-sample\"<br> },<br> “keywords”: [<br> “node”,<br> “heroku”,<br> “express”<br> ],<br> “author”: “Mark Pundsack”,<br> “contributors”: [<br> “Zeke Sikelianos &lt;zeke@sikelianos.com&gt; (http://zeke.sikelianos.com)\"<br> ],<br> “license”: “MIT”<br>}</pre>\n<p>In this above mentioned package.json we have script tag and having start task, so npm scripts enable execution of this tasks using</p>\n<p>npm run start will run node index.js</p>\n<h3>Question 7</h3>\n<p>What is Event-driven programming? And how Node JS is event driven language</p>\n<p>From the name itself its clean that what is event driven something driven by some event so in node js we can write events can trigger something once those event occurs</p>\n<p>Event driven programming : Node js is having event loop on single thread and there is always one event will be running and always there will be one handle to handle that event without interruption.</p>\n<p>Before getting into code of eventEmitter we should understand why event loop is best example of event driven programming.</p>\n<p>Event loop perform two operation in a loop</p>\n<pre><strong>var</strong> events = require(‘events’);<br><strong>var</strong> eventEmitter = <strong>new</strong> events.EventEmitter();<br>//Create an event handler:<br><strong>var</strong> EventHandler = <strong>function</strong> () {<br> console.log(‘I hear a voice!’);<br>}<br>//Assign the event handler to an event:<br>eventEmitter.on(‘’horror’’, EventHandler);<br>//Fire the ‘scream’ event:<br>eventEmitter.emit(‘horror’)</pre>\n<ol>\n<li>Event detection</li>\n<li>Event handler triggering</li>\n</ol>\n<p>There can be different events like on database read do that or on doing this successfully after that run this code.</p>\n<p>Those things can be done using events, event is a core modules where we can emit event from one place and can define handler which can take care of handling that event.</p>\n<p>Example below showing events by extending <strong>EventEmitter</strong> class, its code sample using classes where we have created custom event emitter by extending EventEmitter class and emitting event and capturing it.</p>\n<pre><strong>const</strong> EventEmitter = require(‘events’);<br><strong>class</strong> <strong>MyEmitter</strong> <strong>extends</strong> <strong>EventEmitter</strong> {}<br><strong>const</strong> CustomEmitter = <strong>new</strong> MyEmitter();<br>CustomEmitter.on(‘event’, <strong>function</strong>(a, b) {<br> console.log(‘processed in first iteration’,a,b);<br>});<br>CustomEmitter.emit(‘event’, ‘Hi’, ‘Hello’);</pre>\n<h3>Question 8</h3>\n<p>How Node JS V8 runtime is different from what we have on chrome console</p>\n<p>Chrome console and Node js both are using V8 javascript runtime engine but major difference is Node JS using other c++ core libraries to manage http and socket communication and Chrome V8 engine is mainly browser oriented environments where node js is browserless environment mainly CLI based to execute tasks.</p>\n<p>On browser we have access to window, document and console objects and in Node js we don’t have document &amp; window objects available, it is server side runtime environment which can be executed from command line. Node js mainly used for creating HTTP server, socket communication or reading or writing real time data.</p>\n<h3>Question 9</h3>\n<p>What is the difference between Asynchronous function, Synchronous function or pure functions</p>\n<p><strong>Synchronous function</strong> : Those function which do simple execution and don’t deal with I/O, These are simple function where we can predict output also and have only basic operation having data manipulation</p>\n<p><strong>Asynchronous Function</strong> : Special function which deals with network I/O operations like database read, file read or getting data from some api. These operation always takes time while executing and you do not receive instant response from these api.</p>\n<p>simple example asynchronous code sample :</p>\n<pre><strong>var</strong> userDetails;<br><strong>function</strong> <strong>initialize</strong>() {<br> // Setting URL and headers for request<br><strong>var</strong> options = {<br> url: ‘https://api.github.com/users/narenaryan'<br> };<br><strong>return</strong> <strong>new</strong> Promise(<strong>function</strong>(resolve, reject) {<br> // Do async job<br> request.get(options, <strong>function</strong>(err, resp, body) {<br><strong>if</strong> (err) {<br> reject(err);<br> } <strong>else</strong> {<br> resolve(JSON.parse(body));<br> }<br> })<br> })<br>}</pre>\n<pre><strong>// Synchronous code sample</strong></pre>\n<pre><strong>function</strong> <strong>foo</strong>(){}<br><strong>function</strong> <strong>bar</strong>(){<br> foo();<br>}<br><strong>function</strong> <strong>baz</strong>(){<br> bar();<br>}<br>baz();</pre>\n<h3>Question 10</h3>\n<p>what are different options to write asynchronous code in Node.</p>\n<blockquote>\n<strong>Using setTimeout</strong> we can run some code after defined time</blockquote>\n<blockquote>\n<strong>Using callback</strong> : return function from another function after asynchronous task is over.</blockquote>\n<blockquote>\n<strong>Using Async module </strong>: async module in node js</blockquote>\n<blockquote>\n<strong>Using promises</strong> : using native promises and wait until promise is resolved</blockquote>\n<blockquote>Using some library like b<strong>luebird,Q library</strong>.</blockquote>\n<blockquote>\n<strong>Using async/await</strong> : write less line of code by using async await</blockquote>\n<img src=\"https://medium.com/_/stat?event=post.clientViewed&amp;referrerSource=full_rss&amp;postId=73c2b87c6ae3\" width=\"1\" height=\"1\">\n",
          "enclosure": {},
          "categories": [
              "interview",
              "nodejs",
              "questions",
              "javascript"
          ]
      }
  ]
}

export default blogData;